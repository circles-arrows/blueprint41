<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".txt" #>
<#
try
{
    ApocNamespace documentation = ApocNamespace.Get(Host.ResolvePath("Functions.Apoc.xml"));
#>
#nullable enable

using System;
using System.Linq;

namespace Blueprint41.Neo4j.Model
{
    public abstract partial class QueryTranslator
    {
<#
    foreach (ApocNamespace ns in documentation.All.Where(item => item.Release == Release.Core).OrderBy(item => item.Name))
    {
#>
        #region <#= ns.Name #>

<#
        int columns = ns.Methods.Where(item => item.Release == Release.Core).Select(m => (m.UseParams || m.MinimumArgs != m.TotalArgs) ? m.TranslatorName.Length + 11: m.TranslatorName.Length).Max();
        foreach (ApocMethod m in ns.Methods.Where(item => item.Release == Release.Core).OrderBy(item => item.TranslatorName))
        {
            int whiteSpace = columns - m.TranslatorName.Length;

            if (m.UseParams)
            {
#>
        public virtual string <#= m.TranslatorName #>(int count)<#= Whitespace(whiteSpace - 11) #> => string.Format("<#= ns.Name #>.<#= m.Name #>([{0}])", Args(count));
<#
            }
            else if (m.MinimumArgs != m.TotalArgs)
            {
#>
        public virtual string <#= m.TranslatorName #>(int count)<#= Whitespace(whiteSpace - 11) #> => string.Format("<#= ns.Name #>.<#= m.Name #>({0})", Args(<#= m.MinimumArgs #>, <#= m.TotalArgs #>, count));
<#
            }
            else
            {
#>
        public virtual string <#= m.TranslatorName #><#= Whitespace(whiteSpace) #> => "<#= ns.Name #>.<#= m.Name #>(<#= string.Join(", ", Enumerable.Range(0, m.TotalArgs).Select(item => string.Concat("{", item, "}"))) #>)";
<#
            }
        }
#>

        #endregion

<#
    }
#>
        #region Helper Methods

        private string Args(int count)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", $"The minimum count is 0.");

            return string.Join(", ", Enumerable.Range(0, count).Select(item => string.Concat("{", item, "}")));
        }
        private string Args(int minimum, int maximum, int count)
        {
            if (count < minimum)
                throw new ArgumentOutOfRangeException("count", $"The minimum count is {minimum}.");

            if (count > maximum)
                throw new ArgumentOutOfRangeException("count", $"The maximum count is {maximum}.");

            return string.Join(", ", Enumerable.Range(0, count).Select(item => string.Concat("{", item, "}")));
        }

        #endregion
    }
}
<#
    WriteToFile(Host.ResolvePath(@"..\Neo4j\Persistence\QueryTranslator.Partial.cs"));
#>
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Blueprint41.Query;

public static partial class Functions
{
    public static partial class Apoc
    {
        #region Conversion Methods

<#
    var allMethods = documentation.All.Where(item => item.Release == Release.Core).SelectMany(item => item.Methods).ToList();
    foreach ((string from, string to) in allMethods.SelectMany(item => item.InputParameters).Union(allMethods.SelectMany(item => item.OutputParameters)).SelectMany(item => item.DataTypes.Where(dt => dt.OriginalBp41Type is not null).Select(item => (item.Bp41Type, item.OriginalBp41Type))).Distinct().OrderBy(item => item))
    {
#>
        private static Parameter <#= from #>_To_<#= to #>(<#= from #> value)
        {
            #region <#= from #>_To_<#= to #> -> NoOverwrite

            #error Method '<#= from #>_To_<#= to #>' has no implementation
            throw new NotImplementedException("Method '<#= from #>_To_<#= to #>' has no implementation");

            #endregion <#= from #>_To_<#= to #> -> Overwrite
        }
<#
    }
#>

        #endregion

<#
    PushIndent("    ");
    foreach (var m in documentation.Methods.Where(item => item.Release == Release.Core))
    {
        WriteMethods(documentation, m);
    }
    PopIndent();

    foreach (var ns in documentation.Namespaces.Where(item => item.Release == Release.Core))
    {
#>

        public static partial class <#= ns.CSharpName #>
        {
<#
        PushIndent("        ");
        foreach (var m in ns.Methods.Where(item => item.Release == Release.Core))
        {
            WriteMethods(ns, m);
        }
        PopIndent();
#>
        }
<#    
    }
#>
    }
}
<#
    WriteToFile(Host.ResolvePath(@"Functions.Apoc.Generated.cs"), true);
#>
Generation Successful
---------------------
<#= DateTime.Now.ToString("yyyy-MM-dd hh:mm:ss") #>
<#
}
catch (Exception ex)
{
#>
Generation Failed
-----------------
<#= ex.GetType().Name #>: <#= ex.Message #>
Stacktrace:
<#= ex.StackTrace #>
<#
}
#>
<#+

private string Whitespace(int size)
{
    if (size == 0) return string.Empty;
    return new string(' ', size);
}
private void WriteToFile(string filename, bool withNoOverwrite = false)
{
    string old = (withNoOverwrite) ? File.ReadAllText(filename) : null;
    List<(string key, string value)> sections = string.IsNullOrEmpty(old) ? null : Regex.Matches(old, @"#region (?<key>.+) -> NoOverwrite(?<content>.*)#endregion \k<key> -> Overwrite", RegexOptions.Singleline | RegexOptions.Multiline).Cast<Match>().Select(m => (m.Groups["key"].Value, m.Value)).ToList();

    string content = GenerationEnvironment.ToString();
    if (sections is not null)
    {
        foreach ((string key, string value) in sections)
        {
            string pattern = @$"#region {key} -> NoOverwrite.*#endregion {key} -> Overwrite";
            content = Regex.Replace(content, pattern, value, RegexOptions.Singleline | RegexOptions.Multiline);
        }
    }

    File.WriteAllText(filename, content);

    GenerationEnvironment.Clear();
}

private void WriteDocumentation(ApocNamespace ns, ApocMethod m)
{
#>
    /// <summary>
<#+
    foreach (string line in m.Description.Split('\n'))
    {
#>
    /// <#= line.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\"", "&quot;").Replace("'", "&apos;") #>
<#+
    }
#>
    /// </summary>
<#+
}
private void WriteMethods(ApocNamespace ns, ApocMethod m)
{
    WriteMethodOptionalArguments(ns, m);
}
private void WriteMethodOptionalArguments(ApocNamespace ns, ApocMethod m)
{
    if (m.MinimumArgs != m.TotalArgs)
    {
        foreach (int arguments in Enumerable.Range(m.MinimumArgs, m.TotalArgs - m.MinimumArgs + 1))
            WriteMethodAlternateTypes(ns, m, m.InputParameters.Take(arguments));
    }
    else
    {
        WriteMethodAlternateTypes(ns, m, m.InputParameters);
    }
}
private void WriteMethodAlternateTypes(ApocNamespace ns, ApocMethod m, IEnumerable<ApocParameter> p)
{
    ApocDataType[] d = p.Select(item => item.DataType).ToArray();

    do
    {
        WriteSingleMethod(ns, m, d);
    }
    while (Increment());

    bool Increment()
    {
        for (int index = 0; index < d.Length; index++)
        {
            ApocDataType zero = d[index].Parent.DataType;
            if (zero.AlsoRenderAs is null)
                continue;

            d[index] = d[index].AlsoRenderAs;
            if (d[index] is not null)
                return true;

            d[index] = zero;
        }
        return false;
    }
}
private void WriteSingleMethod(ApocNamespace ns, ApocMethod m, ApocDataType[] d)
{
    WriteDocumentation(ns, m);

    string retval = m.OutputParameters?.FirstOrDefault()?.DataType?.Bp41Type ?? "MiscResult";
    if (m.UseParams)
    {
#>
    public static <#= retval #> <#= m.CSharpName #>(<#= d.First().ToBp41Signature() #>)
    {
        return new <#= retval #>(t => t.<#= m.TranslatorName #>(@<#= d.First().Parent.CSharpName #>.Length), <#= d.First().ToNameWithConversion() #>, null);
    }
<#+
    }
    else if (m.MinimumArgs != m.TotalArgs)
    {
#>
    public static <#= retval #> <#= m.CSharpName #>(<#= string.Join(", ", d.Select(item => item.ToBp41Signature())) #>)
    {
        return new <#= retval #>(t => t.<#= m.TranslatorName #>(<#= d.Length #>), new object[] { <#= string.Join(", ", d.Select(item => item.ToNameWithConversion())) #> }, null);
    }
<#+
    }
    else if (d.Length > 0)
    {
#>
    public static <#= retval #> <#= m.CSharpName #>(<#= string.Join(", ", d.Select(item => item.ToBp41Signature())) #>)
    {
        return new <#= retval #>(t => t.<#= m.TranslatorName #>, new object[] { <#= string.Join(", ", d.Select(item => item.ToNameWithConversion())) #> }, null);
    }
<#+
    }
    else
    {
#>
    public static <#= retval #> <#= m.CSharpName #>()
    {
        return new <#= retval #>(t => t.<#= m.TranslatorName #>, new object[0], null);
    }
<#+
    }
}

public class ApocNamespace
{
    public static ApocNamespace Get(string filename)
    {
        XmlDocument doc = new XmlDocument();
        doc.Load(filename);

        IReadOnlyList<ApocNamespace> all = doc.SelectNodes("/apoc/namespace").Cast<XmlNode>().Select(item => new ApocNamespace(item)).ToList();

        ApocNamespace documentation = all.First(item => item.CSharpName == "Apoc");
        documentation.namespaces.AddRange(all.Where(item => item.CSharpName != "Apoc"));
        foreach (ApocNamespace child in documentation.Namespaces)
            child.Parent = documentation;

        documentation.all.Add(documentation);
        documentation.all.AddRange(documentation.Namespaces);

        return documentation;
    }

    public ApocNamespace(XmlNode node)
    {
        Name = node.Attributes["name"]?.Value;
        TranslatorName = string.Join("", Name.Split('.').Select(item => string.Concat(item.Substring(0, 1).ToUpperInvariant(), item.Substring(1))));
        CSharpName = (TranslatorName.StartsWith("Apoc") && TranslatorName.Length > 4) ? TranslatorName.Substring(4) : TranslatorName;

        methods.AddRange(node.SelectNodes("./method").Cast<XmlNode>().Select(item => new ApocMethod(this, item)));

        Release = Methods.Any(item => item.Release == Release.Core) ? Release.Core : Release.Full;
    }

    public ApocNamespace Parent { get; private set; }
    public string Name { get; private set; }
    public string CSharpName { get; private set; }
    public string TranslatorName { get; private set; }
    public Release Release { get; private set; }

    public IReadOnlyList<ApocMethod> Methods => methods;
    private readonly List<ApocMethod> methods = new List<ApocMethod>();

    public IReadOnlyList<ApocNamespace> Namespaces => namespaces;
    private readonly List<ApocNamespace> namespaces = new List<ApocNamespace>();

    public IReadOnlyList<ApocNamespace> All => (Parent is null) ? all : Parent.All;
    private readonly List<ApocNamespace> all = new List<ApocNamespace>();
}

public class ApocMethod
{
    public ApocMethod(ApocNamespace parent, XmlNode node)
    {
        Parent = parent;
        Name = node.Attributes["name"].Value;
        Description = node.Attributes["description"].Value;
        Type = (MethodType)Enum.Parse(typeof(MethodType), node.Attributes["type"].Value);
        Release = (Release)Enum.Parse(typeof(Release), node.Attributes["release"].Value.Replace("APOC ", ""));
        Warnings= node.SelectNodes("./warning").Cast<XmlNode>().Select(item => item.InnerText.Trim()).ToList();

        CSharpName = string.Concat(Name.Substring(0, 1).ToUpperInvariant(), Name.Substring(1));
        TranslatorName = (Type == MethodType.Function) ? string.Concat("Fn_", Parent.TranslatorName, "_", CSharpName) : string.Concat("Call_", Parent.TranslatorName, "_", CSharpName);

        InputParameters = node.SelectNodes("./input-parameter").Cast<XmlNode>().Select(item => new ApocParameter(this, item)).ToList();
        OutputParameters = node.SelectNodes("./output-parameter").Cast<XmlNode>().Select(item => new ApocParameter(this, item)).ToList();

        UseParams = (InputParameters.Count == 1 && InputParameters[0].Name == "values" && InputParameters[0].DataType.IsList);
        MinimumArgs = InputParameters.Count - InputParameters.Reverse().TakeWhile(item => item.DefaultValue is not null).Count();
        TotalArgs = InputParameters.Count;
    }

    public ApocNamespace Parent { get; private set; }
    public string Name { get; private set; }
    public string CSharpName { get; private set; }
    public string TranslatorName { get; private set; }
    public string Description { get; private set; }
    public MethodType Type { get; private set; }
    public Release Release { get; private set; }
    public IReadOnlyList<ApocParameter> InputParameters { get; private set; }
    public IReadOnlyList<ApocParameter> OutputParameters { get; private set; }
    public IReadOnlyList<string> Warnings { get; private set; }
    public bool UseParams { get; private set; }
    public int MinimumArgs { get; private set; }
    public int TotalArgs { get; private set; }
}

public class ApocParameter
{
    public ApocParameter(ApocMethod parent, XmlNode node)
    {
        Parent = parent;
        Name = node.Attributes["name"]?.Value;

        DataType = new ApocDataType(this, node.Attributes["type"].Value, node.Attributes["neo4j-type"].Value, node.Attributes["list-type"].Value, node.Attributes["override-type"]?.Value, node.Attributes["also-render-as"]?.Value);
        DefaultValue = node.Attributes["default-value"]?.Value;

        string[] parts = Name.Split(' ');
        if (parts.Length > 1)
            CSharpName = string.Concat(parts.First(), string.Join("", parts.Skip(1).Select(item => string.Concat(item.Substring(0, 1).ToUpperInvariant(), item.Substring(1).ToLowerInvariant()))));
        else
            CSharpName = Name; 

        if (DataType.AlsoRenderAs is null)
        {
            DataTypes = new ApocDataType[] { DataType };
        }
        else
        {
            ApocDataType datatype = DataType;
            List<ApocDataType> datatypes = new List<ApocDataType>();
            do
            {
                datatypes.Add(datatype);
                datatype = datatype.AlsoRenderAs;
            }
            while (datatype is not null);

            DataTypes = datatypes.ToArray();
        }
    }

    public ApocMethod Parent { get; private set; }
    public string Name { get; private set; }
    public string CSharpName { get; private set; }
    public ApocDataType DataType { get; private set; }
    public string DefaultValue { get; private set; }

    public IReadOnlyList<ApocDataType> DataTypes { get; private set; }
}

public class ApocDataType
{
    public ApocDataType(ApocParameter parent, string type, string neo4jType, string listType, string overrideType, string alsoRenderAs) : this(parent, type, neo4jType, listType, overrideType, alsoRenderAs?.Split(';')) { }
    private ApocDataType(ApocParameter parent, string type, string neo4jType, string listType, string overrideType, IEnumerable<string> alsoRenderAs)
    {
        Parent = parent;
        Name = type;
        Neo4jType = neo4jType;
        IsList = (listType != "None");
        IsJaggedList = (listType == "JaggedList");

        Bp41Type = (string.IsNullOrEmpty(overrideType)) ? ToBp41Type() : overrideType;
        OriginalBp41Type = (string.IsNullOrEmpty(overrideType)) ? null : ToBp41Type();

        string first = alsoRenderAs?.FirstOrDefault();
        AlsoRenderAs = string.IsNullOrEmpty(first) ? null : new ApocDataType(parent, type, neo4jType, listType, first, alsoRenderAs.Skip(1));
    }

    public ApocParameter Parent { get; private set; }
    public string Name { get; private set; }
    public string Neo4jType { get; private set; }
    public string Bp41Type { get; private set; }
    public string OriginalBp41Type { get; private set; }
    public ApocDataType AlsoRenderAs { get; private set; }
    public bool IsList { get; private set; }
    public bool IsJaggedList { get; private set; }

    private string ToBp41Type()
    {
        string type = Neo4jType switch
        {
            "Any"          => "Misc",
            "Boolean"      => "Boolean",
            "ByteArray"    => "Binary",
            "DateTime"     => "Misc",
            "Duration"     => "Misc",
            "Float"        => "Float",
            "Integer"      => "Numeric",
            "Map"          => "Misc",
            "Node"         => "Alias",
            "Number"       => "Float",
            "Path"         => "Path",
            "Relationship" => "Alias",
            "String"       => "String",
        };

        if (IsJaggedList)
            return string.Concat(type, "JaggedListResult");
        else if (IsList)
            return string.Concat(type, "ListResult");
        else
            return string.Concat(type, "Result");
    }
    public string ToBp41Signature()
    {
        if (Parent.Parent.UseParams)
            return string.Concat("params ", Bp41Type, "[] @", Parent.CSharpName);

        return string.Concat(Bp41Type, " @", Parent.CSharpName);
    }
    public string ToNameWithConversion()
    {
        if (OriginalBp41Type is not null)
            return string.Concat(Bp41Type, "_To_", OriginalBp41Type, "(@", Parent.CSharpName, ")");

        return string.Concat("@", Parent.CSharpName);
    }

}

public enum MethodType
{
    Procedure,
    Function,
}

public enum Release
{
    Core,
    Full,
}

#>