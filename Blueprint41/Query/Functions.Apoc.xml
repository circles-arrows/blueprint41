<apoc version="4.4">
  <namespace name="apoc">
    <method name="case" description="apoc.case([condition, query, condition, query, …​], elseQuery:'', params:{}) yield value - given a list of conditional / read-only query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters" type="Procedure" release="APOC Core">
      <input-parameter name="conditionals" type="LIST? OF ANY?" />
      <input-parameter name="elseQuery" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="help" description="Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string." type="Procedure" release="APOC Core">
      <input-parameter name="proc" type="STRING?" />
      <output-parameter name="core" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="roles" type="LIST? OF STRING?" />
      <output-parameter name="signature" type="STRING?" />
      <output-parameter name="text" type="STRING?" />
      <output-parameter name="type" type="STRING?" />
      <output-parameter name="writes" type="BOOLEAN?" />
    </method>
    <method name="version" description="RETURN apoc.version() | return the current APOC installed version" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="when" description="apoc.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes read-only ifQuery or elseQuery with the given parameters" type="Procedure" release="APOC Core">
      <input-parameter name="condition" type="BOOLEAN?" />
      <input-parameter name="elseQuery" type="STRING?" />
      <input-parameter name="ifQuery" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.agg">
    <method name="first" description="apoc.agg.first(value) - returns first value" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="graph" description="apoc.agg.graph(path) - returns map of graph {nodes, relationships} of all distinct nodes and relationships" type="Function" release="APOC Core">
      <input-parameter name="element" type="ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="last" description="apoc.agg.last(value) - returns last value" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="maxItems" description="apoc.agg.maxItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where value is the maximum value present, and items are all items with the same value. The number of items can be optionally limited." type="Function" release="APOC Core">
      <input-parameter name="groupLimit" type="INTEGER?" />
      <input-parameter name="item" type="ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="median" description="apoc.agg.median(number) - returns median for non-null numeric values" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="minItems" description="apoc.agg.minItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where value is the minimum value present, and items are all items with the same value. The number of items can be optionally limited." type="Function" release="APOC Core">
      <input-parameter name="groupLimit" type="INTEGER?" />
      <input-parameter name="item" type="ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="nth" description="apoc.agg.nth(value,offset) - returns value of nth row (or -1 for last)" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="percentiles" description="apoc.agg.percentiles(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns given percentiles for values" type="Function" release="APOC Core">
      <input-parameter name="percentiles" type="LIST? OF FLOAT?" />
      <input-parameter name="value" type="NUMBER?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="product" description="apoc.agg.product(number) - returns given product for non-null values" type="Function" release="APOC Core">
      <input-parameter name="number" type="NUMBER?" />
      <output-parameter name="Return Value" type="NUMBER?" />
    </method>
    <method name="slice" description="apoc.agg.slice(value, start, length) - returns subset of non-null values, start is 0 based and length can be -1" type="Function" release="APOC Core">
      <input-parameter name="from" type="INTEGER?" />
      <input-parameter name="to" type="INTEGER?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="statistics" description="apoc.agg.statistics(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns numeric statistics (percentiles, min,minNonZero,max,total,mean,stdev) for values" type="Function" release="APOC Core">
      <input-parameter name="percentiles" type="LIST? OF FLOAT?" />
      <input-parameter name="value" type="NUMBER?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.algo">
    <method name="allSimplePaths" description="apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|&lt;WORKS_WITH|IS_MANAGER_OF&gt;', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes" type="Procedure" release="APOC Core">
      <input-parameter name="endNode" type="NODE?" />
      <input-parameter name="maxNodes" type="INTEGER?" />
      <input-parameter name="relationshipTypesAndDirections" type="STRING?" />
      <input-parameter name="startNode" type="NODE?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="aStar" description="apoc.algo.aStar(startNode, endNode, 'KNOWS|&lt;WORKS_WITH|IS_MANAGER_OF&gt;', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function" type="Procedure" release="APOC Core">
      <input-parameter name="endNode" type="NODE?" />
      <input-parameter name="latPropertyName" type="STRING?" />
      <input-parameter name="lonPropertyName" type="STRING?" />
      <input-parameter name="relationshipTypesAndDirections" type="STRING?" />
      <input-parameter name="startNode" type="NODE?" />
      <input-parameter name="weightPropertyName" type="STRING?" />
      <output-parameter name="path" type="PATH?" />
      <output-parameter name="weight" type="FLOAT?" />
    </method>
    <method name="aStarConfig" description="apoc.algo.aStar(startNode, endNode, 'KNOWS|&lt;WORKS_WITH|IS_MANAGER_OF&gt;', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="endNode" type="NODE?" />
      <input-parameter name="relationshipTypesAndDirections" type="STRING?" />
      <input-parameter name="startNode" type="NODE?" />
      <output-parameter name="path" type="PATH?" />
      <output-parameter name="weight" type="FLOAT?" />
    </method>
    <method name="cover" description="apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes" type="Procedure" release="APOC Core">
      <input-parameter name="nodes" type="ANY?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
    <method name="dijkstra" description="apoc.algo.dijkstra(startNode, endNode, 'KNOWS|&lt;WORKS_WITH|IS_MANAGER_OF&gt;', 'distance', defaultValue, numberOfWantedResults) YIELD path, weight - run dijkstra with relationship property name as cost function" type="Procedure" release="APOC Core">
      <input-parameter name="defaultWeight" type="FLOAT?" />
      <input-parameter name="endNode" type="NODE?" />
      <input-parameter name="numberOfWantedPaths" type="INTEGER?" />
      <input-parameter name="relationshipTypesAndDirections" type="STRING?" />
      <input-parameter name="startNode" type="NODE?" />
      <input-parameter name="weightPropertyName" type="STRING?" />
      <output-parameter name="path" type="PATH?" />
      <output-parameter name="weight" type="FLOAT?" />
    </method>
    <method name="dijkstraWithDefaultWeight" description="apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|&lt;WORKS_WITH|IS_MANAGER_OF&gt;', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist" type="Procedure" release="APOC Core">
      <input-parameter name="defaultWeight" type="FLOAT?" />
      <input-parameter name="endNode" type="NODE?" />
      <input-parameter name="relationshipTypesAndDirections" type="STRING?" />
      <input-parameter name="startNode" type="NODE?" />
      <input-parameter name="weightPropertyName" type="STRING?" />
      <output-parameter name="path" type="PATH?" />
      <output-parameter name="weight" type="FLOAT?" />
    </method>
  </namespace>
  <namespace name="apoc.any">
    <method name="properties" description="returns properties for virtual and real, nodes, rels and maps" type="Function" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="thing" type="ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="property" description="returns property for virtual and real, nodes, rels and maps" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="thing" type="ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
  </namespace>
  <namespace name="apoc.atomic">
    <method name="add" description="apoc.atomic.add(node/relatonship,propertyName,number) Sums the property’s value with the 'number' value" type="Procedure" release="APOC Core">
      <input-parameter name="container" type="ANY?" />
      <input-parameter name="number" type="NUMBER?" />
      <input-parameter name="propertyName" type="STRING?" />
      <input-parameter name="times" type="INTEGER?" />
      <output-parameter name="container" type="ANY?" />
      <output-parameter name="newValue" type="ANY?" />
      <output-parameter name="oldValue" type="ANY?" />
      <output-parameter name="property" type="STRING?" />
    </method>
    <method name="concat" description="apoc.atomic.concat(node/relatonship,propertyName,string) Concats the property’s value with the 'string' value" type="Procedure" release="APOC Core">
      <input-parameter name="container" type="ANY?" />
      <input-parameter name="propertyName" type="STRING?" />
      <input-parameter name="string" type="STRING?" />
      <input-parameter name="times" type="INTEGER?" />
      <output-parameter name="container" type="ANY?" />
      <output-parameter name="newValue" type="ANY?" />
      <output-parameter name="oldValue" type="ANY?" />
      <output-parameter name="property" type="STRING?" />
    </method>
    <method name="insert" description="apoc.atomic.insert(node/relatonship,propertyName,position,value) insert a value into the property’s array value at 'position'" type="Procedure" release="APOC Core">
      <input-parameter name="container" type="ANY?" />
      <input-parameter name="position" type="INTEGER?" />
      <input-parameter name="propertyName" type="STRING?" />
      <input-parameter name="times" type="INTEGER?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="container" type="ANY?" />
      <output-parameter name="newValue" type="ANY?" />
      <output-parameter name="oldValue" type="ANY?" />
      <output-parameter name="property" type="STRING?" />
    </method>
    <method name="remove" description="apoc.atomic.remove(node/relatonship,propertyName,position) remove the element at position 'position'" type="Procedure" release="APOC Core">
      <input-parameter name="container" type="ANY?" />
      <input-parameter name="position" type="INTEGER?" />
      <input-parameter name="propertyName" type="STRING?" />
      <input-parameter name="times" type="INTEGER?" />
      <output-parameter name="container" type="ANY?" />
      <output-parameter name="newValue" type="ANY?" />
      <output-parameter name="oldValue" type="ANY?" />
      <output-parameter name="property" type="STRING?" />
    </method>
    <method name="subtract" description="apoc.atomic.subtract(node/relatonship,propertyName,number) Subtracts the 'number' value to the property’s value" type="Procedure" release="APOC Core">
      <input-parameter name="container" type="ANY?" />
      <input-parameter name="number" type="NUMBER?" />
      <input-parameter name="propertyName" type="STRING?" />
      <input-parameter name="times" type="INTEGER?" />
      <output-parameter name="container" type="ANY?" />
      <output-parameter name="newValue" type="ANY?" />
      <output-parameter name="oldValue" type="ANY?" />
      <output-parameter name="property" type="STRING?" />
    </method>
    <method name="update" description="apoc.atomic.update(node/relatonship,propertyName,updateOperation) update a property’s value with a cypher operation (ex. &quot;n.prop1+n.prop2&quot;)" type="Procedure" release="APOC Core">
      <input-parameter name="container" type="ANY?" />
      <input-parameter name="operation" type="STRING?" />
      <input-parameter name="propertyName" type="STRING?" />
      <input-parameter name="times" type="INTEGER?" />
      <output-parameter name="container" type="ANY?" />
      <output-parameter name="newValue" type="ANY?" />
      <output-parameter name="oldValue" type="ANY?" />
      <output-parameter name="property" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.bitwise">
    <method name="op" description="apoc.bitwise.op(60,'|',13) bitwise operations a &amp; b, a | b, a ^ b, ~a, a &gt;&gt; b, a &gt;&gt;&gt; b, a &lt;&lt; b. returns the result of the bitwise operation" type="Function" release="APOC Core">
      <input-parameter name="a" type="INTEGER?" />
      <input-parameter name="b" type="INTEGER?" />
      <input-parameter name="operator" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.bolt">
    <method name="execute" description="apoc.bolt.execute(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for reads and writes" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="kernelTransaction" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="row" type="MAP?" />
    </method>
    <method name="load" description="apoc.bolt.load(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for read" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="kernelTransaction" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="row" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.bolt.load">
    <method name="fromLocal" description="No documentation available." type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="localStatement" type="STRING?" />
      <input-parameter name="remoteStatement" type="STRING?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="row" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.cluster" />
  <namespace name="apoc.coll">
    <method name="avg" description="apoc.coll.avg([0.5,1,2.3])" type="Function" release="APOC Core">
      <input-parameter name="numbers" type="LIST? OF NUMBER?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="avgDuration" description="apoc.coll.avgDuration([duration('P2DT3H'), duration('PT1H45S'), …​]) -  returns the average of a list of duration values" type="Function" release="APOC Full">
      <input-parameter name="durations" type="LIST? OF DURATION?" />
      <output-parameter name="Return Value" type="DURATION?" />
    </method>
    <method name="combinations" description="apoc.coll.combinations(coll, minSelect, maxSelect:minSelect) - Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="maxSelect" type="INTEGER?" />
      <input-parameter name="minSelect" type="INTEGER?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="contains" description="apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="containsAll" description="apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="containsAllSorted" description="apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="containsDuplicates" description="apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="containsSorted" description="apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="different" description="apoc.coll.different(values) - returns true if values are different" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="disjunction" description="apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists" type="Function" release="APOC Core">
      <input-parameter name="first" type="LIST? OF ANY?" />
      <input-parameter name="second" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="dropDuplicateNeighbors" description="apoc.coll.dropDuplicateNeighbors(list) - remove duplicate consecutive objects in a list" type="Function" release="APOC Core">
      <input-parameter name="list" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="duplicates" description="apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="duplicatesWithCount" description="apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by item and count (e.g., [{item: xyz, count:2}, {item:zyx, count:5}])" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="elements" description="apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type" type="Procedure" release="APOC Core">
      <input-parameter name="limit" type="INTEGER?" />
      <input-parameter name="offset" type="INTEGER?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="_1" type="ANY?" />
      <output-parameter name="_10" type="ANY?" />
      <output-parameter name="_10b" type="BOOLEAN?" />
      <output-parameter name="_10f" type="FLOAT?" />
      <output-parameter name="_10i" type="INTEGER?" />
      <output-parameter name="_10l" type="LIST? OF ANY?" />
      <output-parameter name="_10m" type="MAP?" />
      <output-parameter name="_10n" type="NODE?" />
      <output-parameter name="_10p" type="PATH?" />
      <output-parameter name="_10r" type="RELATIONSHIP?" />
      <output-parameter name="_10s" type="STRING?" />
      <output-parameter name="_1b" type="BOOLEAN?" />
      <output-parameter name="_1f" type="FLOAT?" />
      <output-parameter name="_1i" type="INTEGER?" />
      <output-parameter name="_1l" type="LIST? OF ANY?" />
      <output-parameter name="_1m" type="MAP?" />
      <output-parameter name="_1n" type="NODE?" />
      <output-parameter name="_1p" type="PATH?" />
      <output-parameter name="_1r" type="RELATIONSHIP?" />
      <output-parameter name="_1s" type="STRING?" />
      <output-parameter name="_2" type="ANY?" />
      <output-parameter name="_2b" type="BOOLEAN?" />
      <output-parameter name="_2f" type="FLOAT?" />
      <output-parameter name="_2i" type="INTEGER?" />
      <output-parameter name="_2l" type="LIST? OF ANY?" />
      <output-parameter name="_2m" type="MAP?" />
      <output-parameter name="_2n" type="NODE?" />
      <output-parameter name="_2p" type="PATH?" />
      <output-parameter name="_2r" type="RELATIONSHIP?" />
      <output-parameter name="_2s" type="STRING?" />
      <output-parameter name="_3" type="ANY?" />
      <output-parameter name="_3b" type="BOOLEAN?" />
      <output-parameter name="_3f" type="FLOAT?" />
      <output-parameter name="_3i" type="INTEGER?" />
      <output-parameter name="_3l" type="LIST? OF ANY?" />
      <output-parameter name="_3m" type="MAP?" />
      <output-parameter name="_3n" type="NODE?" />
      <output-parameter name="_3p" type="PATH?" />
      <output-parameter name="_3r" type="RELATIONSHIP?" />
      <output-parameter name="_3s" type="STRING?" />
      <output-parameter name="_4" type="ANY?" />
      <output-parameter name="_4b" type="BOOLEAN?" />
      <output-parameter name="_4f" type="FLOAT?" />
      <output-parameter name="_4i" type="INTEGER?" />
      <output-parameter name="_4l" type="LIST? OF ANY?" />
      <output-parameter name="_4m" type="MAP?" />
      <output-parameter name="_4n" type="NODE?" />
      <output-parameter name="_4p" type="PATH?" />
      <output-parameter name="_4r" type="RELATIONSHIP?" />
      <output-parameter name="_4s" type="STRING?" />
      <output-parameter name="_5" type="ANY?" />
      <output-parameter name="_5b" type="BOOLEAN?" />
      <output-parameter name="_5f" type="FLOAT?" />
      <output-parameter name="_5i" type="INTEGER?" />
      <output-parameter name="_5l" type="LIST? OF ANY?" />
      <output-parameter name="_5m" type="MAP?" />
      <output-parameter name="_5n" type="NODE?" />
      <output-parameter name="_5p" type="PATH?" />
      <output-parameter name="_5r" type="RELATIONSHIP?" />
      <output-parameter name="_5s" type="STRING?" />
      <output-parameter name="_6" type="ANY?" />
      <output-parameter name="_6b" type="BOOLEAN?" />
      <output-parameter name="_6f" type="FLOAT?" />
      <output-parameter name="_6i" type="INTEGER?" />
      <output-parameter name="_6l" type="LIST? OF ANY?" />
      <output-parameter name="_6m" type="MAP?" />
      <output-parameter name="_6n" type="NODE?" />
      <output-parameter name="_6p" type="PATH?" />
      <output-parameter name="_6r" type="RELATIONSHIP?" />
      <output-parameter name="_6s" type="STRING?" />
      <output-parameter name="_7" type="ANY?" />
      <output-parameter name="_7b" type="BOOLEAN?" />
      <output-parameter name="_7f" type="FLOAT?" />
      <output-parameter name="_7i" type="INTEGER?" />
      <output-parameter name="_7l" type="LIST? OF ANY?" />
      <output-parameter name="_7m" type="MAP?" />
      <output-parameter name="_7n" type="NODE?" />
      <output-parameter name="_7p" type="PATH?" />
      <output-parameter name="_7r" type="RELATIONSHIP?" />
      <output-parameter name="_7s" type="STRING?" />
      <output-parameter name="_8" type="ANY?" />
      <output-parameter name="_8b" type="BOOLEAN?" />
      <output-parameter name="_8f" type="FLOAT?" />
      <output-parameter name="_8i" type="INTEGER?" />
      <output-parameter name="_8l" type="LIST? OF ANY?" />
      <output-parameter name="_8m" type="MAP?" />
      <output-parameter name="_8n" type="NODE?" />
      <output-parameter name="_8p" type="PATH?" />
      <output-parameter name="_8r" type="RELATIONSHIP?" />
      <output-parameter name="_8s" type="STRING?" />
      <output-parameter name="_9" type="ANY?" />
      <output-parameter name="_9b" type="BOOLEAN?" />
      <output-parameter name="_9f" type="FLOAT?" />
      <output-parameter name="_9i" type="INTEGER?" />
      <output-parameter name="_9l" type="LIST? OF ANY?" />
      <output-parameter name="_9m" type="MAP?" />
      <output-parameter name="_9n" type="NODE?" />
      <output-parameter name="_9p" type="PATH?" />
      <output-parameter name="_9r" type="RELATIONSHIP?" />
      <output-parameter name="_9s" type="STRING?" />
      <output-parameter name="elements" type="INTEGER?" />
    </method>
    <method name="fill" description="apoc.coll.fill(item, count) - returns a list with the given count of items" type="Function" release="APOC Core">
      <input-parameter name="count" type="INTEGER?" />
      <input-parameter name="item" type="STRING?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="flatten" description="apoc.coll.flatten(coll, [recursive]) - flattens list (nested if recursive is true)" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="recursive" type="BOOLEAN?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="frequencies" description="apoc.coll.frequencies(coll) - returns a list of frequencies of the items in the collection, keyed by item and count (e.g., [{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}])" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="frequenciesAsMap" description="apoc.coll.frequenciesAsMap(coll) - return a map of frequencies of the items in the collection, key item, value count (e.g., {1:2, 2:1})" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="indexOf" description="apoc.coll.indexOf(coll, value) | position of value in the list" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="insertAll" description="apoc.coll.insertAll(coll, index, values) | insert values at index" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="index" type="INTEGER?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="intersection" description="apoc.coll.intersection(first, second) - returns the unique intersection of the two lists" type="Function" release="APOC Core">
      <input-parameter name="first" type="LIST? OF ANY?" />
      <input-parameter name="second" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="isEqualCollection" description="apoc.coll.isEqualCollection(coll, values) return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="max" description="apoc.coll.max([0.5,1,2.3])" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="min" description="apoc.coll.min([0.5,1,2.3])" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="occurrences" description="apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="item" type="ANY?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="pairs" description="apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null]" type="Function" release="APOC Core">
      <input-parameter name="list" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="pairsMin" description="apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]" type="Function" release="APOC Core">
      <input-parameter name="list" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="pairWithOffset" description="apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset" type="Procedure" release="APOC Core">
      <input-parameter name="offset" type="INTEGER?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
    </method>
    <method name="partition" description="apoc.coll.partition(list,batchSize)" type="Procedure" release="APOC Core">
      <input-parameter name="batchSize" type="INTEGER?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
    </method>
    <method name="randomItem" description="apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="randomItems" description="apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again" type="Function" release="APOC Core">
      <input-parameter name="allowRepick" type="BOOLEAN?" />
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="itemCount" type="INTEGER?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="removeAll" description="apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed" type="Function" release="APOC Core">
      <input-parameter name="first" type="LIST? OF ANY?" />
      <input-parameter name="second" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="reverse" description="apoc.coll.reverse(coll) - returns reversed list" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="runningTotal" description="apoc.coll.runningTotal(list1) - returns an accumulative array. For example apoc.coll.runningTotal([1,2,3.5]) return [1,3,6.5]" type="Function" release="APOC Core">
      <input-parameter name="list" type="LIST? OF NUMBER?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="set" description="apoc.coll.set(coll, index, value) | set index to value" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <input-parameter name="index" type="INTEGER?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="shuffle" description="apoc.coll.shuffle(coll) - returns the shuffled list" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="sort" description="apoc.coll.sort(coll) sort on Collections" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="sortMaps" description="apoc.coll.sortMaps([maps], 'name') - sort maps by property" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF MAP?" />
      <input-parameter name="prop" type="STRING?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="sortMulti" description="apoc.coll.sortMulti(coll, ['^name','age'],[limit],[skip]) - sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF MAP?" />
      <input-parameter name="limit" type="INTEGER?" />
      <input-parameter name="orderFields" type="LIST? OF STRING?" />
      <input-parameter name="skip" type="INTEGER?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="sortNodes" description="apoc.coll.sortNodes([nodes], 'name') sort nodes by property" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF NODE?" />
      <input-parameter name="prop" type="STRING?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="sortText" description="apoc.coll.sortText(coll) sort on string based collections" type="Function" release="APOC Core">
      <input-parameter name="coll" type="LIST? OF STRING?" />
      <input-parameter name="conf" type="MAP?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="split" description="apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists" type="Procedure" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
    <method name="stdev" description="apoc.coll.stdev(list, isBiasCorrected) - returns the sample or population standard deviation with isBiasCorrected true or false respectively. For example apoc.coll.stdev([10, 12, 23]) return 7" type="Function" release="APOC Core">
      <input-parameter name="isBiasCorrected" type="BOOLEAN?" />
      <input-parameter name="list" type="LIST? OF NUMBER?" />
      <output-parameter name="Return Value" type="NUMBER?" />
    </method>
    <method name="sum" description="apoc.coll.sum([0.5,1,2.3])" type="Function" release="APOC Core">
      <input-parameter name="numbers" type="LIST? OF NUMBER?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="sumLongs" description="apoc.coll.sumLongs([1,3,3])" type="Function" release="APOC Core">
      <input-parameter name="numbers" type="LIST? OF NUMBER?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="toSet" description="apoc.coll.toSet([list]) returns a unique list backed by a set" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="union" description="apoc.coll.union(first, second) - creates the distinct union of the 2 lists" type="Function" release="APOC Core">
      <input-parameter name="first" type="LIST? OF ANY?" />
      <input-parameter name="second" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="unionAll" description="apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists" type="Function" release="APOC Core">
      <input-parameter name="first" type="LIST? OF ANY?" />
      <input-parameter name="second" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="zip" description="apoc.coll.zip([list1],[list2])" type="Function" release="APOC Core">
      <input-parameter name="list1" type="LIST? OF ANY?" />
      <input-parameter name="list2" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="zipToRows" description="apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair" type="Procedure" release="APOC Core">
      <input-parameter name="list1" type="LIST? OF ANY?" />
      <input-parameter name="list2" type="LIST? OF ANY?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
  </namespace>
  <namespace name="apoc.config">
    <method name="list" description="apoc.config.list | Lists the Neo4j configuration as key,value table" type="Procedure" release="APOC Full">
      <output-parameter name="key" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="map" description="apoc.config.map | Lists the Neo4j configuration as map" type="Procedure" release="APOC Full">
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.convert">
    <method name="fromJsonList" description="apoc.convert.fromJsonList('[1,2,3]'[,'json-path', 'path-options'])" type="Function" release="APOC Core">
      <input-parameter name="list" type="STRING?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="pathOptions" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="fromJsonMap" description="apoc.convert.fromJsonMap('{&quot;a&quot;:42,&quot;b&quot;:&quot;foo&quot;,&quot;c&quot;:[1,2,3]}'[,'json-path', 'path-options'])" type="Function" release="APOC Core">
      <input-parameter name="map" type="STRING?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="pathOptions" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="getJsonProperty" description="apoc.convert.getJsonProperty(node,key[,'json-path', 'path-options']) - converts serialized JSON in property back to original object" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="pathOptions" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="getJsonPropertyMap" description="apoc.convert.getJsonPropertyMap(node,key[,'json-path', 'path-options']) - converts serialized JSON in property back to map" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="pathOptions" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="setJsonProperty" description="apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node" type="Procedure" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="value" type="ANY?" />
    </method>
    <method name="toBoolean" description="apoc.convert.toBoolean(value) | tries it’s best to convert the value to a boolean" type="Function" release="APOC Core">
      <input-parameter name="bool" type="ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="toBooleanList" description="apoc.convert.toBooleanList(value) | tries it’s best to convert the value to a list of booleans" type="Function" release="APOC Core">
      <input-parameter name="list" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="toFloat" description="apoc.convert.toFloat(value) | tries it’s best to convert the value to a float" type="Function" release="APOC Core">
      <input-parameter name="object" type="ANY?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="toInteger" description="apoc.convert.toInteger(value) | tries it’s best to convert the value to an integer" type="Function" release="APOC Core">
      <input-parameter name="object" type="ANY?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="toIntList" description="apoc.convert.toIntList(value) | tries it’s best to convert the value to a list of integers" type="Function" release="APOC Core">
      <input-parameter name="list" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="toJson" description="apoc.convert.toJson([1,2,3]) or toJson({a:42,b:&quot;foo&quot;,c:[1,2,3]}) or toJson(NODE/REL/PATH)" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toList" description="apoc.convert.toList(value) | tries it’s best to convert the value to a list" type="Function" release="APOC Core">
      <input-parameter name="list" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="toMap" description="apoc.convert.toMap(value) | tries it’s best to convert the value to a map" type="Function" release="APOC Core">
      <input-parameter name="map" type="ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="toNode" description="apoc.convert.toNode(value) | tries it’s best to convert the value to a node" type="Function" release="APOC Core">
      <input-parameter name="node" type="ANY?" />
      <output-parameter name="Return Value" type="NODE?" />
    </method>
    <method name="toNodeList" description="apoc.convert.toNodeList(value) | tries it’s best to convert the value to a list of nodes" type="Function" release="APOC Core">
      <input-parameter name="list" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="toRelationship" description="apoc.convert.toRelationship(value) | tries it’s best to convert the value to a relationship" type="Function" release="APOC Core">
      <input-parameter name="relationship" type="ANY?" />
      <output-parameter name="Return Value" type="RELATIONSHIP?" />
    </method>
    <method name="toRelationshipList" description="apoc.convert.toRelationshipList(value) | tries it’s best to convert the value to a list of relationships" type="Function" release="APOC Core">
      <input-parameter name="list" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="toSortedJsonMap" description="apoc.convert.toSortedJsonMap(node|map, ignoreCase:true) - returns a JSON map with keys sorted alphabetically, with optional case sensitivity" type="Function" release="APOC Core">
      <input-parameter name="ignoreCase" type="BOOLEAN?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toString" description="apoc.convert.toString(value) | tries it’s best to convert the value to a string" type="Function" release="APOC Core">
      <input-parameter name="string" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toStringList" description="apoc.convert.toStringList(value) | tries it’s best to convert the value to a list of strings" type="Function" release="APOC Core">
      <input-parameter name="list" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="toTree" description="apoc.convert.toTree([paths],[lowerCaseRels=true], [config]) creates a stream of nested documents representing the at least one root of these paths" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="lowerCaseRels" type="BOOLEAN?" />
      <input-parameter name="paths" type="LIST? OF PATH?" />
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.couchbase">
    <method name="append" description="apoc.couchbase.append(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="content" type="BYTEARRAY?" />
      <input-parameter name="documentId" type="STRING?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <output-parameter name="cas" type="INTEGER?" />
      <output-parameter name="content" type="BYTEARRAY?" />
      <output-parameter name="expiry" type="INTEGER?" />
      <output-parameter name="id" type="STRING?" />
      <output-parameter name="mutationToken" type="MAP?" />
    </method>
    <method name="exists" description="apoc.couchbase.exists(hostOrKey, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="documentId" type="STRING?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <output-parameter name="value" type="BOOLEAN?" />
    </method>
    <method name="get" description="apoc.couchbase.get(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="documentId" type="STRING?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <output-parameter name="cas" type="INTEGER?" />
      <output-parameter name="content" type="MAP?" />
      <output-parameter name="expiry" type="INTEGER?" />
      <output-parameter name="id" type="STRING?" />
      <output-parameter name="mutationToken" type="MAP?" />
    </method>
    <method name="namedParamsQuery" description="apoc.couchbase.namedParamsQuery(hostkOrKey, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <input-parameter name="paramNames" type="LIST? OF STRING?" />
      <input-parameter name="paramValues" type="LIST? OF ANY?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="queryResult" type="LIST? OF MAP?" />
    </method>
    <method name="posParamsQuery" description="apoc.couchbase.posParamsQuery(hostOrKey, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="queryResult" type="LIST? OF MAP?" />
    </method>
    <method name="prepend" description="apoc.couchbase.prepend(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="content" type="BYTEARRAY?" />
      <input-parameter name="documentId" type="STRING?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <output-parameter name="cas" type="INTEGER?" />
      <output-parameter name="content" type="BYTEARRAY?" />
      <output-parameter name="expiry" type="INTEGER?" />
      <output-parameter name="id" type="STRING?" />
      <output-parameter name="mutationToken" type="MAP?" />
    </method>
    <method name="query" description="apoc.couchbase.query(hostOrKey, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="queryResult" type="LIST? OF MAP?" />
    </method>
    <method name="replace" description="apoc.couchbase.replace(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="documentId" type="STRING?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <input-parameter name="json" type="STRING?" />
      <output-parameter name="cas" type="INTEGER?" />
      <output-parameter name="content" type="MAP?" />
      <output-parameter name="expiry" type="INTEGER?" />
      <output-parameter name="id" type="STRING?" />
      <output-parameter name="mutationToken" type="MAP?" />
    </method>
    <method name="upsert" description="apoc.couchbase.upsert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID." type="Procedure" release="APOC Full">
      <input-parameter name="bucket" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="documentId" type="STRING?" />
      <input-parameter name="hostOrKey" type="STRING?" />
      <input-parameter name="json" type="STRING?" />
      <output-parameter name="cas" type="INTEGER?" />
      <output-parameter name="content" type="MAP?" />
      <output-parameter name="expiry" type="INTEGER?" />
      <output-parameter name="id" type="STRING?" />
      <output-parameter name="mutationToken" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.create">
    <method name="addLabels" description="apoc.create.addLabels( [node,id,ids,nodes], ['Label',…​]) - adds the given labels to the node or nodes" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="nodes" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="clonePathsToVirtual" description="apoc.create.clonePathsToVirtual" type="Procedure" release="APOC Core">
      <input-parameter name="paths" type="LIST? OF PATH?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="clonePathToVirtual" description="apoc.create.clonePathToVirtual" type="Procedure" release="APOC Core">
      <input-parameter name="path" type="PATH?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="node" description="apoc.create.node(['Label'], {key:value,…​}) - create node with dynamic labels" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="props" type="MAP?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="nodes" description="apoc.create.nodes(['Label'], [{key:value,…​}]) create multiple nodes with dynamic labels" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="props" type="LIST? OF MAP?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="relationship" description="apoc.create.relationship(person1,'KNOWS',{key:value,…​}, person2) create relationship with dynamic rel-type" type="Procedure" release="APOC Core">
      <input-parameter name="from" type="NODE?" />
      <input-parameter name="props" type="MAP?" />
      <input-parameter name="relType" type="STRING?" />
      <input-parameter name="to" type="NODE?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
    <method name="removeLabels" description="apoc.create.removeLabels( [node,id,ids,nodes], ['Label',…​]) - removes the given labels from the node or nodes" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="nodes" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="removeProperties" description="apoc.create.removeProperties( [node,id,ids,nodes], [keys]) - removes the given properties from the nodes(s)" type="Procedure" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="nodes" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="removeRelProperties" description="apoc.create.removeRelProperties( [rel,id,ids,rels], [keys]) - removes the given properties from the relationship(s)" type="Procedure" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="rels" type="ANY?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
    <method name="setLabels" description="apoc.create.setLabels( [node,id,ids,nodes], ['Label',…​]) - sets the given labels, non matching labels are removed on the node or nodes" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="nodes" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="setProperties" description="apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given properties on the nodes(s)" type="Procedure" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="nodes" type="ANY?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="setProperty" description="apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)" type="Procedure" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="nodes" type="ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="setRelProperties" description="apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given properties on the relationship(s)" type="Procedure" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="rels" type="ANY?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
    <method name="setRelProperty" description="apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)" type="Procedure" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="relationships" type="ANY?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
    <method name="uuid" description="apoc.create.uuid() - creates an UUID" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="uuids" description="apoc.create.uuids(count) yield uuid - creates 'count' UUIDs" type="Procedure" release="APOC Core">
      <input-parameter name="count" type="INTEGER?" />
      <output-parameter name="row" type="INTEGER?" />
      <output-parameter name="uuid" type="STRING?" />
    </method>
    <method name="virtualPath" description="apoc.create.virtualPath(['LabelA'],{key:value},'KNOWS',{key:value,…​},['LabelB'],{key:value}) returns a virtual path of nodes joined by a relationship and the associated properties" type="Procedure" release="APOC Core">
      <input-parameter name="labelsM" type="LIST? OF STRING?" />
      <input-parameter name="labelsN" type="LIST? OF STRING?" />
      <input-parameter name="m" type="MAP?" />
      <input-parameter name="n" type="MAP?" />
      <input-parameter name="props" type="MAP?" />
      <input-parameter name="relType" type="STRING?" />
      <output-parameter name="from" type="NODE?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
      <output-parameter name="to" type="NODE?" />
    </method>
    <method name="vNode" description="apoc.create.vNode(['Label'], {key:value,…​}) returns a virtual node" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="props" type="MAP?" />
    </method>
    <method name="vNodes" description="apoc.create.vNodes(['Label'], [{key:value,…​}]) returns virtual nodes" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="props" type="LIST? OF MAP?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="vPattern" description="apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,…​}, {_labels:['LabelB'],key:value}) returns a virtual pattern" type="Procedure" release="APOC Core">
      <input-parameter name="from" type="MAP?" />
      <input-parameter name="props" type="MAP?" />
      <input-parameter name="relType" type="STRING?" />
      <input-parameter name="to" type="MAP?" />
      <output-parameter name="from" type="NODE?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
      <output-parameter name="to" type="NODE?" />
    </method>
    <method name="vPatternFull" description="apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,…​},['LabelB'],{key:value}) returns a virtual pattern" type="Procedure" release="APOC Core">
      <input-parameter name="labelsM" type="LIST? OF STRING?" />
      <input-parameter name="labelsN" type="LIST? OF STRING?" />
      <input-parameter name="m" type="MAP?" />
      <input-parameter name="n" type="MAP?" />
      <input-parameter name="props" type="MAP?" />
      <input-parameter name="relType" type="STRING?" />
      <output-parameter name="from" type="NODE?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
      <output-parameter name="to" type="NODE?" />
    </method>
    <method name="vRelationship" description="apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,…​}, nodeTo) returns a virtual relationship" type="Procedure" release="APOC Core">
      <input-parameter name="from" type="NODE?" />
      <input-parameter name="props" type="MAP?" />
      <input-parameter name="relType" type="STRING?" />
      <input-parameter name="to" type="NODE?" />
    </method>
  </namespace>
  <namespace name="apoc.create.virtual">
    <method name="fromNode" description="apoc.create.virtual.fromNode(node, [propertyNames]) returns a virtual node built from an existing node with only the requested properties" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="propertyNames" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="NODE?" />
    </method>
  </namespace>
  <namespace name="apoc.custom">
    <method name="asFunction" description="apoc.custom.asFunction(name, statement, outputs, inputs, forceSingle, description) - register a custom cypher function" type="Procedure" release="APOC Full">
      <input-parameter name="description" type="STRING?" />
      <input-parameter name="forceSingle" type="BOOLEAN?" />
      <input-parameter name="inputs" type="LIST? OF LIST? OF STRING?" />
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="outputs" type="STRING?" />
      <input-parameter name="statement" type="STRING?" />
    </method>
    <method name="asProcedure" description="apoc.custom.asProcedure(name, statement, mode, outputs, inputs, description) - register a custom cypher procedure" type="Procedure" release="APOC Full">
      <input-parameter name="description" type="STRING?" />
      <input-parameter name="inputs" type="LIST? OF LIST? OF STRING?" />
      <input-parameter name="mode" type="STRING?" />
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="outputs" type="LIST? OF LIST? OF STRING?" />
      <input-parameter name="statement" type="STRING?" />
    </method>
    <method name="declareFunction" description="apoc.custom.declareFunction(signature, statement, forceSingle, description) - register a custom cypher function" type="Procedure" release="APOC Full">
      <input-parameter name="description" type="STRING?" />
      <input-parameter name="forceSingle" type="BOOLEAN?" />
      <input-parameter name="signature" type="STRING?" />
      <input-parameter name="statement" type="STRING?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
    <method name="declareProcedure" description="apoc.custom.declareProcedure(signature, statement, mode, description) - register a custom cypher procedure" type="Procedure" release="APOC Full">
      <input-parameter name="description" type="STRING?" />
      <input-parameter name="mode" type="STRING?" />
      <input-parameter name="signature" type="STRING?" />
      <input-parameter name="statement" type="STRING?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
    <method name="removeFunction" description="apoc.custom.removeFunction(name, type) - remove the targeted custom function" type="Procedure" release="APOC Full">
      <input-parameter name="name" type="STRING?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
    <method name="removeProcedure" description="apoc.custom.removeProcedure(name) - remove the targeted custom procedure" type="Procedure" release="APOC Full">
      <input-parameter name="name" type="STRING?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
  </namespace>
  <namespace name="apoc.cypher">
    <method name="doIt" description="apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters" type="Procedure" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="mapParallel" description="apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _" type="Procedure" release="APOC Full">
      <input-parameter name="fragment" type="STRING?" />
      <input-parameter name="list" type="LIST? OF ANY?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="mapParallel2" description="apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _" type="Procedure" release="APOC Full">
      <input-parameter name="fragment" type="STRING?" />
      <input-parameter name="list" type="LIST? OF ANY?" />
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="partitions" type="INTEGER?" />
      <input-parameter name="timeout" type="INTEGER?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="parallel" description="apoc.cypher.parallel(fragment, paramMap, keyList) yield value - executes fragments in parallel through a list defined in paramMap with a key keyList" type="Procedure" release="APOC Full">
      <input-parameter name="fragment" type="STRING?" />
      <input-parameter name="parallelizeOn" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="parallel2" description="apoc.cypher.parallel2(fragment, paramMap, keyList) yield value - executes fragments in parallel batches through a list defined in paramMap with a key keyList" type="Procedure" release="APOC Full">
      <input-parameter name="fragment" type="STRING?" />
      <input-parameter name="parallelizeOn" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="run" description="apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters - currently no schema operations" type="Procedure" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="runFile" description="apoc.cypher.runFile(file or url,[{statistics:true,timeout:10,parameters:{}}]) - runs each statement in the file, all semicolon separated - currently no schema operations" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <output-parameter name="result" type="MAP?" />
      <output-parameter name="row" type="INTEGER?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
    <method name="runFiles" description="apoc.cypher.runFiles([files or urls],[{statistics:true,timeout:10,parameters:{}}])) - runs each statement in the files, all semicolon separated" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="LIST? OF STRING?" />
      <output-parameter name="result" type="MAP?" />
      <output-parameter name="row" type="INTEGER?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
    <method name="runFirstColumn" description="use either apoc.cypher.runFirstColumnMany for a list return or apoc.cypher.runFirstColumnSingle for returning the first row of the first column" type="Function" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="expectMultipleValues" type="BOOLEAN?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="runFirstColumnMany" description="apoc.cypher.runFirstColumnMany(statement, params) - executes statement with given parameters, returns first column only collected into a list, params are available as identifiers" type="Function" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="runFirstColumnSingle" description="apoc.cypher.runFirstColumnSingle(statement, params) - executes statement with given parameters, returns first element of the first column only, params are available as identifiers" type="Function" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="runMany" description="apoc.cypher.runMany('cypher;\nstatements;', $params, [{statistics:true,timeout:10}]) - runs each semicolon separated statement and returns summary - currently no schema operations" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="result" type="MAP?" />
      <output-parameter name="row" type="INTEGER?" />
    </method>
    <method name="runManyReadOnly" description="apoc.cypher.runManyReadOnly('cypher;\nstatements;', $params, [{statistics:true,timeout:10}]) - runs each semicolon separated, read-only statement and returns summary - currently no schema operations" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="result" type="MAP?" />
      <output-parameter name="row" type="INTEGER?" />
    </method>
    <method name="runSchema" description="apoc.cypher.runSchema(statement, params) yield value - executes query schema statement with the given parameters" type="Procedure" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="runSchemaFile" description="apoc.cypher.runSchemaFile(file or url,[{statistics:true,timeout:10}]) - allows only schema operations, runs each schema statement in the file, all semicolon separated" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <output-parameter name="result" type="MAP?" />
      <output-parameter name="row" type="INTEGER?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
    <method name="runSchemaFiles" description="apoc.cypher.runSchemaFiles([files or urls],{statistics:true,timeout:10}) - allows only schema operations, runs each schema statement in the files, all semicolon separated" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="LIST? OF STRING?" />
      <output-parameter name="result" type="MAP?" />
      <output-parameter name="row" type="INTEGER?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
    <method name="runTimeboxed" description="apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort kernelTransaction after timeout ms if not finished" type="Procedure" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="timeout" type="INTEGER?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="runWrite" description="apoc.cypher.runWrite(statement, params) yield value - alias for apoc.cypher.doIt" type="Procedure" release="APOC Core">
      <input-parameter name="cypher" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.data">
    <method name="domain" description="apoc.data.domain('url_or_email_address') YIELD domain - extract the domain name from a url or an email address. If nothing was found, yield null." type="Function" release="APOC Core">
      <input-parameter name="url_or_email_address" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="email" description="apoc.data.email('email_address') as {personal,user,domain} - extract the personal name, user and domain as a map" type="Function" release="APOC Full">
      <input-parameter name="email_address" type="STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="url" description="apoc.data.url('url') as {protocol,host,port,path,query,file,anchor,user} | turn URL into map structure" type="Function" release="APOC Core">
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.date">
    <method name="convert" description="apoc.date.convert(12345, 'ms', 'd') - convert a timestamp in one time unit into one of a different time unit" type="Function" release="APOC Core">
      <input-parameter name="time" type="INTEGER?" />
      <input-parameter name="toUnit" type="STRING?" />
      <input-parameter name="unit" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="convertFormat" description="apoc.date.convertFormat('Tue, 14 May 2019 14:52:06 -0400', 'rfc_1123_date_time', 'iso_date_time') - convert a String of one date format into a String of another date format." type="Function" release="APOC Core">
      <input-parameter name="convertTo" type="STRING?" />
      <input-parameter name="currentFormat" type="STRING?" />
      <input-parameter name="temporal" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="currentTimestamp" description="apoc.date.currentTimestamp() - returns System.currentTimeMillis() at the time it was called. The value is current throughout transaction execution, and is different from Cypher’s timestamp() function, which does not update within a transaction." type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="expire" description="CALL apoc.date.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and ttl property" type="Procedure" release="APOC Full">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="time" type="INTEGER?" />
      <input-parameter name="timeUnit" type="STRING?" />
    </method>
    <method name="expireIn" description="CALL apoc.date.expireIn(node,time,'time-unit') - expire node after specified length of time time by setting :TTL label and ttl property" type="Procedure" release="APOC Full">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="timeDelta" type="INTEGER?" />
      <input-parameter name="timeUnit" type="STRING?" />
    </method>
    <method name="field" description="apoc.date.field(12345,('ms|s|m|h|d|month|year'),('TZ')" type="Function" release="APOC Core">
      <input-parameter name="time" type="INTEGER?" />
      <input-parameter name="timezone" type="STRING?" />
      <input-parameter name="unit" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="fields" description="apoc.date.fields('2012-12-23',('yyyy-MM-dd')) - return columns and a map representation of date parsed with the given format with entries for years,months,weekdays,days,hours,minutes,seconds,zoneid" type="Function" release="APOC Core">
      <input-parameter name="date" type="STRING?" />
      <input-parameter name="pattern" type="STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="format" description="apoc.date.format(12345,('ms|s|m|h|d'),('yyyy-MM-dd HH:mm:ss zzz'),('TZ')) - get string representation of time value optionally using the specified unit (default ms) using specified format (default ISO) and specified time zone (default current TZ)" type="Function" release="APOC Core">
      <input-parameter name="format" type="STRING?" />
      <input-parameter name="time" type="INTEGER?" />
      <input-parameter name="timezone" type="STRING?" />
      <input-parameter name="unit" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="fromISO8601" description="apoc.date.fromISO8601('yyyy-MM-ddTHH:mm:ss.SSSZ') - return number representation of time in EPOCH format" type="Function" release="APOC Core">
      <input-parameter name="time" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="parse" description="apoc.date.parse('2012-12-23','ms|s|m|h|d','yyyy-MM-dd') - parse date string using the specified format into the specified time unit" type="Function" release="APOC Core">
      <input-parameter name="format" type="STRING?" />
      <input-parameter name="time" type="STRING?" />
      <input-parameter name="timezone" type="STRING?" />
      <input-parameter name="unit" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="parseAsZonedDateTime" description="apoc.date.parseAsZonedDateTime('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') - parse date string using the specified format to specified timezone" type="Function" release="APOC Core">
      <input-parameter name="format" type="STRING?" />
      <input-parameter name="time" type="STRING?" />
      <input-parameter name="timezone" type="STRING?" />
      <output-parameter name="Return Value" type="DATETIME?" />
    </method>
    <method name="systemTimezone" description="apoc.date.systemTimezone() - returns the system timezone display name" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toISO8601" description="apoc.date.toISO8601(12345,('ms|s|m|h|d') - return string representation of time in ISO8601 format" type="Function" release="APOC Core">
      <input-parameter name="time" type="INTEGER?" />
      <input-parameter name="unit" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toYears" description="toYears(timestamp) or toYears(date[,format]) - converts timestamp into floating point years" type="Function" release="APOC Core">
      <input-parameter name="format" type="STRING?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
  </namespace>
  <namespace name="apoc.diff" />
  <namespace name="apoc.do" />
  <namespace name="apoc.dv">
    <method name="queryAndLink" description="Query a virtualized resource by name and return virtual nodes linked using virtual rels to the node passed as first param" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="params" type="ANY?" />
      <input-parameter name="relName" type="STRING?" />
      <output-parameter name="path" type="PATH?" />
    </method>
  </namespace>
  <namespace name="apoc.dv.catalog" />
  <namespace name="apoc.es">
    <method name="getRaw" description="apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search" type="Procedure" release="APOC Full">
      <input-parameter name="host" type="STRING?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="payload" type="ANY?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="post" description="apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search" type="Procedure" release="APOC Full">
      <input-parameter name="host" type="STRING?" />
      <input-parameter name="index" type="STRING?" />
      <input-parameter name="payload" type="MAP?" />
      <input-parameter name="query" type="ANY?" />
      <input-parameter name="type" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="postRaw" description="apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search" type="Procedure" release="APOC Full">
      <input-parameter name="host" type="STRING?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="payload" type="ANY?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="put" description="apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search" type="Procedure" release="APOC Full">
      <input-parameter name="host" type="STRING?" />
      <input-parameter name="id" type="STRING?" />
      <input-parameter name="index" type="STRING?" />
      <input-parameter name="payload" type="MAP?" />
      <input-parameter name="query" type="ANY?" />
      <input-parameter name="type" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="stats" description="apoc.es.stats(host-url-Key) - elastic search statistics" type="Procedure" release="APOC Full">
      <input-parameter name="host" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.example">
    <method name="movies" description="apoc.example.movies() | Creates the sample movies graph" type="Procedure" release="APOC Core">
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.export">
    <method name="cypherAll" description="apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="cleanupStatements" type="STRING?" />
      <output-parameter name="cypherStatements" type="STRING?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="nodeStatements" type="STRING?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="relationshipStatements" type="STRING?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="schemaStatements" type="STRING?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
    <method name="cypherData" description="apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="rels" type="LIST? OF RELATIONSHIP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="cleanupStatements" type="STRING?" />
      <output-parameter name="cypherStatements" type="STRING?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="nodeStatements" type="STRING?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="relationshipStatements" type="STRING?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="schemaStatements" type="STRING?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
    <method name="cypherGraph" description="apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <input-parameter name="graph" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="cleanupStatements" type="STRING?" />
      <output-parameter name="cypherStatements" type="STRING?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="nodeStatements" type="STRING?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="relationshipStatements" type="STRING?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="schemaStatements" type="STRING?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
    <method name="cypherQuery" description="apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher kernelTransaction incl. indexes as cypher statements to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <input-parameter name="query" type="STRING?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="cleanupStatements" type="STRING?" />
      <output-parameter name="cypherStatements" type="STRING?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="nodeStatements" type="STRING?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="relationshipStatements" type="STRING?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="schemaStatements" type="STRING?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.export.csv">
    <method name="all" description="apoc.export.csv.all(file,config) - exports whole database as csv to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
    <method name="data" description="apoc.export.csv.data(nodes,rels,file,config) - exports given nodes and relationships as csv to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="rels" type="LIST? OF RELATIONSHIP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.export.cypher">
    <method name="schema" description="apoc.export.cypher.schema(file,config) - exports all schema indexes and constraints to cypher" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="file" type="STRING?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="cleanupStatements" type="STRING?" />
      <output-parameter name="cypherStatements" type="STRING?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="nodeStatements" type="STRING?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="relationshipStatements" type="STRING?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="schemaStatements" type="STRING?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.export.graphml" />
  <namespace name="apoc.export.json" />
  <namespace name="apoc.export.xls" />
  <namespace name="apoc.generate">
    <method name="ba" description="apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model" type="Procedure" release="APOC Full">
      <input-parameter name="edgesPerNode" type="INTEGER?" />
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="noNodes" type="INTEGER?" />
      <input-parameter name="type" type="STRING?" />
    </method>
    <method name="complete" description="apoc.generate.complete(noNodes, label, type) - generates a random complete graph" type="Procedure" release="APOC Full">
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="noNodes" type="INTEGER?" />
      <input-parameter name="type" type="STRING?" />
    </method>
    <method name="er" description="apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model" type="Procedure" release="APOC Full">
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="noEdges" type="INTEGER?" />
      <input-parameter name="noNodes" type="INTEGER?" />
      <input-parameter name="type" type="STRING?" />
    </method>
    <method name="simple" description="apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution" type="Procedure" release="APOC Full">
      <input-parameter name="degrees" type="LIST? OF INTEGER?" />
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="type" type="STRING?" />
    </method>
    <method name="ws" description="apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model" type="Procedure" release="APOC Full">
      <input-parameter name="beta" type="FLOAT?" />
      <input-parameter name="degree" type="INTEGER?" />
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="noNodes" type="INTEGER?" />
      <input-parameter name="type" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.gephi" />
  <namespace name="apoc.get">
    <method name="rels" description="apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id’s" type="Procedure" release="APOC Full">
      <input-parameter name="relationships" type="ANY?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
  </namespace>
  <namespace name="apoc.graph">
    <method name="from" description="apoc.graph.from(data,'name',{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in" type="Procedure" release="APOC Core">
      <input-parameter name="data" type="ANY?" />
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="properties" type="MAP?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="fromCypher" description="apoc.graph.fromCypher('kernelTransaction',{params},'name',{properties}) - creates a virtual graph object for later processing" type="Procedure" release="APOC Core">
      <input-parameter name="kernelTransaction" type="STRING?" />
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="properties" type="MAP?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="fromData" description="apoc.graph.fromData([nodes],[relationships],'name',{properties}) | creates a virtual graph object for later processing" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="properties" type="MAP?" />
      <input-parameter name="relationships" type="LIST? OF RELATIONSHIP?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="fromDB" description="apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="properties" type="MAP?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="fromDocument" description="apoc.graph.fromDocument({json}, {config}) yield graph - transform JSON documents into graph structures" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="json" type="ANY?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="fromPath" description="apoc.graph.fromPath(path,'name',{properties}) - creates a virtual graph object for later processing" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="path" type="PATH?" />
      <input-parameter name="properties" type="MAP?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="fromPaths" description="apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="paths" type="LIST? OF PATH?" />
      <input-parameter name="properties" type="MAP?" />
      <output-parameter name="graph" type="MAP?" />
    </method>
    <method name="validateDocument" description="apoc.graph.validateDocument({json}, {config}) yield row - validates the json, return the result of the validation" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="json" type="ANY?" />
      <output-parameter name="row" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.hashing">
    <method name="fingerprint" description="calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash. Unsuitable for cryptographic use-cases." type="Function" release="APOC Core">
      <input-parameter name="propertyExcludes" type="LIST? OF STRING?" />
      <input-parameter name="some object" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="fingerprintGraph" description="calculate a checksum (md5) over a the full graph. Be aware that this function does use in-memomry datastructures depending on the size of your graph. Unsuitable for cryptographic use-cases." type="Function" release="APOC Core">
      <input-parameter name="propertyExcludes" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="fingerprinting" description="calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash. Unsuitable for cryptographic use-cases." type="Function" release="APOC Core">
      <input-parameter name="conf" type="MAP?" />
      <input-parameter name="some object" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.import">
    <method name="csv" description="apoc.import.csv(nodes, relationships, config) - imports nodes and relationships from the provided CSV files with given labels and types" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF MAP?" />
      <input-parameter name="relationships" type="LIST? OF MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
    <method name="graphml" description="apoc.import.graphml(urlOrBinaryFile,config) - imports graphml file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="urlOrBinaryFile" type="ANY?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
    <method name="json" description="apoc.import.json(urlOrBinaryFile,config) - imports the json list to the provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="urlOrBinaryFile" type="ANY?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
    <method name="xml" description="apoc.import.xml(file,config) - imports graph from provided file" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="urlOrBinary" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
  </namespace>
  <namespace name="apoc.json">
    <method name="path" description="apoc.json.path('{json}' [,'json-path' , 'path-options'])" type="Function" release="APOC Core">
      <input-parameter name="json" type="STRING?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="pathOptions" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="ANY?" />
    </method>
    <method name="validate" description="apoc.json.validate('{json}' [,'json-path' , 'path-options']) - to check if the json is correct (returning an empty result) or not" type="Procedure" release="APOC Full">
      <input-parameter name="json" type="STRING?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="pathOptions" type="LIST? OF STRING?" />
      <output-parameter name="value" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.label" />
  <namespace name="apoc.load">
    <method name="csvParams" description="apoc.load.csvParams('urlOrBinary', {httpHeader: value}, payload, {config}) YIELD lineNo, list, map - load from CSV URL (e.g. web-api) while sending headers / payload to load CSV from URL as stream of values,&#xA; config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="httpHeaders" type="MAP?" />
      <input-parameter name="payload" type="STRING?" />
      <input-parameter name="urlOrBinary" type="ANY?" />
      <output-parameter name="lineNo" type="INTEGER?" />
      <output-parameter name="list" type="LIST? OF ANY?" />
      <output-parameter name="map" type="MAP?" />
      <output-parameter name="stringMap" type="MAP?" />
      <output-parameter name="strings" type="LIST? OF STRING?" />
    </method>
    <method name="directory" description="apoc.load.directory('pattern', 'urlDir', {config}) YIELD value - Loads list of all files in the folder specified by the parameter urlDir satisfying the given pattern. If the parameter urlDir is not specified or empty, the files of the import folder are loaded instead." type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="pattern" type="STRING?" />
      <input-parameter name="urlDir" type="STRING?" />
      <output-parameter name="value" type="STRING?" />
    </method>
    <method name="driver" description="apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database" type="Procedure" release="APOC Full">
      <input-parameter name="driverClass" type="STRING?" />
    </method>
    <method name="html" description="apoc.load.html('url',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="query" type="MAP?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="htmlPlainText" description="apoc.load.htmlPlainText('urlOrHtml',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="query" type="MAP?" />
      <input-parameter name="urlOrHtml" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="jdbc" description="apoc.load.jdbc('key or url','table or statement', params, config) YIELD row - load from relational database, from a full table or a sql statement" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="jdbc" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
      <input-parameter name="tableOrSql" type="STRING?" />
      <output-parameter name="row" type="MAP?" />
    </method>
    <method name="jdbcParams" description="deprecated - please use: apoc.load.jdbc('key or url','',[params]) YIELD row - load from relational database, from a sql statement with parameters" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="jdbc" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
      <input-parameter name="sql" type="STRING?" />
      <output-parameter name="row" type="MAP?" />
    </method>
    <method name="jdbcUpdate" description="apoc.load.jdbcUpdate('key or url','statement',[params],config) YIELD row - update relational database, from a SQL statement with optional parameters" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="jdbc" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
      <input-parameter name="query" type="STRING?" />
      <output-parameter name="row" type="MAP?" />
    </method>
    <method name="jsonArray" description="apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="jsonParams" description="apoc.load.jsonParams('urlOrKeyOrBinary',{header:value},payload, config) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="headers" type="MAP?" />
      <input-parameter name="path" type="STRING?" />
      <input-parameter name="payload" type="STRING?" />
      <input-parameter name="urlOrKeyOrBinary" type="ANY?" />
      <output-parameter name="value" type="MAP?" />
      <warning>Neo4j will now be able to read from anywhere on the file system, so be sure that this is your intention before setting this property.</warning>
    </method>
    <method name="ldap" description="apoc.load.ldap(&quot;key&quot; or {connectionMap},{searchMap}) Load entries from an ldap source (yield entry)" type="Procedure" release="APOC Full">
      <input-parameter name="connection" type="ANY?" />
      <input-parameter name="search" type="MAP?" />
      <output-parameter name="entry" type="MAP?" />
    </method>
    <method name="xls" description="apoc.load.xls('url','selector',{config}) YIELD lineNo, list, map - load XLS fom URL as stream of row values,&#xA; config contains any of: {skip:1,limit:5,header:false,ignore:['tmp'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false, dateFormat:'iso_date', dateParse:['dd-MM-yyyy']}}" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="selector" type="STRING?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="lineNo" type="INTEGER?" />
      <output-parameter name="list" type="LIST? OF ANY?" />
      <output-parameter name="map" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.load.directory.async" />
  <namespace name="apoc.lock" />
  <namespace name="apoc.lock.read" />
  <namespace name="apoc.log">
    <method name="debug" description="apoc.log.debug(message, params) - logs debug message" type="Procedure" release="APOC Full">
      <input-parameter name="message" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
    </method>
    <method name="error" description="apoc.log.error(message, params) - logs error message" type="Procedure" release="APOC Full">
      <input-parameter name="message" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
    </method>
    <method name="info" description="apoc.log.info(message, params) - logs info message" type="Procedure" release="APOC Full">
      <input-parameter name="message" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
    </method>
    <method name="stream" description="apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="path" type="STRING?" />
      <output-parameter name="line" type="STRING?" />
      <output-parameter name="lineNo" type="INTEGER?" />
      <output-parameter name="path" type="STRING?" />
    </method>
    <method name="warn" description="apoc.log.warn(message, params) - logs warn message" type="Procedure" release="APOC Full">
      <input-parameter name="message" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
    </method>
  </namespace>
  <namespace name="apoc.map">
    <method name="clean" description="apoc.map.clean(map,[skip,keys],[skip,values]) yield map filters the keys and values contained in those lists, good for data cleaning from CSV/JSON" type="Function" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="fromLists" description="apoc.map.fromLists([keys],[values])" type="Function" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="fromNodes" description="apoc.map.fromNodes(label, property)" type="Function" release="APOC Core">
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="property" type="STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="fromPairs" description="apoc.map.fromPairs([[key,value],[key2,value2],…​])" type="Function" release="APOC Core">
      <input-parameter name="pairs" type="LIST? OF LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="fromValues" description="apoc.map.fromValues([key1,value1,key2,value2,…​])" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="groupBy" description="apoc.map.groupBy([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with single values" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="groupByMulti" description="apoc.map.groupByMulti([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with list values" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="merge" description="apoc.map.merge(first,second) - merges two maps" type="Function" release="APOC Core">
      <input-parameter name="first" type="MAP?" />
      <input-parameter name="second" type="MAP?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="mergeList" description="apoc.map.mergeList([{maps}]) yield value - merges all maps in the list into one" type="Function" release="APOC Core">
      <input-parameter name="maps" type="LIST? OF MAP?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="mget" description="apoc.map.mget(map,key,[defaults],[fail=true])  - returns list of values for keys or throws exception if one of the key doesn’t exist and no default value given at that position" type="Function" release="APOC Core">
      <input-parameter name="fail" type="BOOLEAN?" />
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="removeKey" description="apoc.map.removeKey(map,key,{recursive:true/false}) - remove the key from the map (recursively if recursive is true)" type="Function" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="map" type="MAP?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="removeKeys" description="apoc.map.removeKeys(map,[keys],{recursive:true/false}) - remove the keys from the map (recursively if recursive is true)" type="Function" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="map" type="MAP?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="setEntry" description="apoc.map.setEntry(map,key,value)" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="setKey" description="apoc.map.setKey(map,key,value)" type="Function" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="setLists" description="apoc.map.setLists(map,[keys],[values])" type="Function" release="APOC Core">
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="setPairs" description="apoc.map.setPairs(map,[[key1,value1],[key2,value2])" type="Function" release="APOC Core">
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="pairs" type="LIST? OF LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="setValues" description="apoc.map.setValues(map,[key1,value1,key2,value2])" type="Function" release="APOC Core">
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="pairs" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="sortedProperties" description="apoc.map.sortedProperties(map, ignoreCase:true) - returns a list of key/value list pairs, with pairs sorted by keys alphabetically, with optional case sensitivity" type="Function" release="APOC Core">
      <input-parameter name="ignoreCase" type="BOOLEAN?" />
      <input-parameter name="map" type="MAP?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="submap" description="apoc.map.submap(map,keys,[defaults],[fail=true])  - returns submap for keys or throws exception if one of the key doesn’t exist and no default value given at that position" type="Function" release="APOC Core">
      <input-parameter name="fail" type="BOOLEAN?" />
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="map" type="MAP?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="unflatten" description="apoc.map.unflatten(map, delimiter:'.') yield map - unflat from items separated by delimiter string to nested items (reverse of apoc.map.flatten function)" type="Function" release="APOC Core">
      <input-parameter name="delimiter" type="STRING?" />
      <input-parameter name="map" type="MAP?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="updateTree" description="apoc.map.updateTree(tree,key,) returns map - adds the {data} map on each level of the nested tree, where the key-value pairs match" type="Function" release="APOC Core">
      <input-parameter name="data" type="LIST? OF LIST? OF ANY?" />
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="tree" type="MAP?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
    <method name="values" description="apoc.map.values(map, [key1,key2,key3,…​],[addNullsForMissing]) returns list of values indicated by the keys" type="Function" release="APOC Core">
      <input-parameter name="addNullsForMissing" type="BOOLEAN?" />
      <input-parameter name="keys" type="LIST? OF STRING?" />
      <input-parameter name="map" type="MAP?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
  </namespace>
  <namespace name="apoc.math">
    <method name="cosh" description="apoc.math.cosh(val) | returns the hyperbolic cosin" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="coth" description="apoc.math.coth(val) | returns the hyperbolic cotangent" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="csch" description="apoc.math.csch(val) | returns the hyperbolic cosecant" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="maxByte" description="apoc.math.maxByte() | return the maximum value an byte can have" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="maxDouble" description="apoc.math.maxDouble() | return the largest positive finite value of type double" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="maxInt" description="apoc.math.maxInt() | return the maximum value an int can have" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="maxLong" description="apoc.math.maxLong() | return the maximum value a long can have" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="minByte" description="apoc.math.minByte() | return the minimum value an byte can have" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="minDouble" description="apoc.math.minDouble() | return the smallest positive nonzero value of type double" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="minInt" description="apoc.math.minInt() | return the minimum value an int can have" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="minLong" description="apoc.math.minLong() | return the minimum value a long can have" type="Function" release="APOC Core">
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="regr" description="apoc.math.regr(label, propertyY, propertyX) - It calculates the coefficient of determination (R-squared) for the values of propertyY and propertyX in the provided label" type="Procedure" release="APOC Core">
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="propertyX" type="STRING?" />
      <input-parameter name="propertyY" type="STRING?" />
      <output-parameter name="avgX" type="FLOAT?" />
      <output-parameter name="avgY" type="FLOAT?" />
      <output-parameter name="r2" type="FLOAT?" />
      <output-parameter name="slope" type="FLOAT?" />
    </method>
    <method name="round" description="apoc.math.round(value,[prec],mode=[CEILING,FLOOR,UP,DOWN,HALF_EVEN,HALF_DOWN,HALF_UP,DOWN,UNNECESSARY])" type="Function" release="APOC Core">
      <input-parameter name="mode" type="STRING?" />
      <input-parameter name="precision" type="INTEGER?" />
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="sech" description="apoc.math.sech(val) | returns the hyperbolic secant" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="sigmoid" description="apoc.math.sigmoid(val) | returns the sigmoid value" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="sigmoidPrime" description="apoc.math.sigmoidPrime(val) | returns the sigmoid prime [ sigmoid(val) * (1 - sigmoid(val)) ]" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="sinh" description="apoc.math.sinh(val) | returns the hyperbolic sin" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="tanh" description="apoc.math.tanh(val) | returns the hyperbolic tangent" type="Function" release="APOC Core">
      <input-parameter name="value" type="FLOAT?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
  </namespace>
  <namespace name="apoc.merge" />
  <namespace name="apoc.merge.node">
    <method name="eager" description="apoc.merge.node.eager(['Label'], identProps:{key:value, …​}, onCreateProps:{key:value,…​}, onMatchProps:{key:value,…​}}) - merge nodes eagerly, with dynamic labels, with support for setting properties ON CREATE or ON MATCH" type="Procedure" release="APOC Core">
      <input-parameter name="identProps" type="MAP?" />
      <input-parameter name="label" type="LIST? OF STRING?" />
      <input-parameter name="onMatchProps" type="MAP?" />
      <input-parameter name="props" type="MAP?" />
      <output-parameter name="node" type="NODE?" />
    </method>
  </namespace>
  <namespace name="apoc.merge.relationship" />
  <namespace name="apoc.meta">
    <method name="graphSample" description="apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <output-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="relationships" type="LIST? OF RELATIONSHIP?" />
    </method>
    <method name="nodeTypeProperties" description="apoc.meta.nodeTypeProperties()" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <output-parameter name="mandatory" type="BOOLEAN?" />
      <output-parameter name="nodeLabels" type="LIST? OF STRING?" />
      <output-parameter name="nodeType" type="STRING?" />
      <output-parameter name="propertyName" type="STRING?" />
      <output-parameter name="propertyObservations" type="INTEGER?" />
      <output-parameter name="propertyTypes" type="LIST? OF STRING?" />
      <output-parameter name="totalObservations" type="INTEGER?" />
    </method>
    <method name="relTypeProperties" description="apoc.meta.relTypeProperties()" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <output-parameter name="mandatory" type="BOOLEAN?" />
      <output-parameter name="propertyName" type="STRING?" />
      <output-parameter name="propertyObservations" type="INTEGER?" />
      <output-parameter name="propertyTypes" type="LIST? OF STRING?" />
      <output-parameter name="relType" type="STRING?" />
      <output-parameter name="sourceNodeLabels" type="LIST? OF STRING?" />
      <output-parameter name="targetNodeLabels" type="LIST? OF STRING?" />
      <output-parameter name="totalObservations" type="INTEGER?" />
    </method>
    <method name="subGraph" description="apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <output-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="relationships" type="LIST? OF RELATIONSHIP?" />
    </method>
    <method name="typeName" description="apoc.meta.typeName(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.meta.cypher">
    <method name="isType" description="apoc.meta.cypher.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,MAP,LIST OF &lt;TYPE&gt;,POINT,DATE,DATE_TIME,LOCAL_TIME,LOCAL_DATE_TIME,TIME,DURATION)" type="Function" release="APOC Core">
      <input-parameter name="type" type="STRING?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="type" description="apoc.meta.cypher.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,MAP,LIST OF &lt;TYPE&gt;,POINT,DATE,DATE_TIME,LOCAL_TIME,LOCAL_DATE_TIME,TIME,DURATION)" type="Function" release="APOC Core">
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="types" description="apoc.meta.cypher.types(node-relationship-map)  - returns a map of keys to types" type="Function" release="APOC Core">
      <input-parameter name="properties" type="ANY?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.meta.data">
    <method name="of" description="apoc.meta.data.of({graph}, {config})  - examines a subset of the graph to provide a tabular meta information" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="graph" type="ANY?" />
      <output-parameter name="array" type="BOOLEAN?" />
      <output-parameter name="count" type="INTEGER?" />
      <output-parameter name="elementType" type="STRING?" />
      <output-parameter name="existence" type="BOOLEAN?" />
      <output-parameter name="index" type="BOOLEAN?" />
      <output-parameter name="label" type="STRING?" />
      <output-parameter name="left" type="INTEGER?" />
      <output-parameter name="other" type="LIST? OF STRING?" />
      <output-parameter name="otherLabels" type="LIST? OF STRING?" />
      <output-parameter name="property" type="STRING?" />
      <output-parameter name="right" type="INTEGER?" />
      <output-parameter name="sample" type="LIST? OF ANY?" />
      <output-parameter name="type" type="STRING?" />
      <output-parameter name="unique" type="BOOLEAN?" />
    </method>
  </namespace>
  <namespace name="apoc.meta.graph" />
  <namespace name="apoc.meta.nodes">
    <method name="count" description="apoc.meta.nodes.count([labels], $config) - Returns the sum of the nodes with a label present in the list." type="Function" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.metrics">
    <method name="storage" description="apoc.metrics.storage(directorySetting) - retrieve storage metrics about the devices Neo4j uses for data storage. directorySetting may be any valid neo4j directory setting name, such as 'dbms.directories.data'.  If null is provided as a directorySetting, you will get back all available directory settings.  For a list of available directory settings, see the Neo4j operations manual reference on configuration settings.   Directory settings are not paths, they are a neo4j.conf setting key name" type="Procedure" release="APOC Full">
      <input-parameter name="directorySetting" type="STRING?" />
      <output-parameter name="freeSpaceBytes" type="INTEGER?" />
      <output-parameter name="percentFree" type="FLOAT?" />
      <output-parameter name="setting" type="STRING?" />
      <output-parameter name="totalSpaceBytes" type="INTEGER?" />
      <output-parameter name="usableSpaceBytes" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.model" />
  <namespace name="apoc.mongo">
    <method name="aggregate" description="apoc.mongo.aggregate(uri, pipeline, $config) yield value - perform an aggregate operation on mongodb collection" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="pipeline" type="LIST? OF MAP?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="delete" description="apoc.mongo.delete(uri, query, $config) - delete the given documents from the mongodb collection and returns the number of affected documents" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="query" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="find" description="apoc.mongo.find(uri, query, $config) yield value - perform a find operation on mongodb collection" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="query" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.mongodb" />
  <namespace name="apoc.mongodb.get">
    <method name="byObjectId" description="apoc.mongodb.get.byObjectId(hostOrKey, db, collection, objectIdValue, config(default:{})) - get the document by Object id value" type="Procedure" release="APOC Full">
      <input-parameter name="collection" type="STRING?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="db" type="STRING?" />
      <input-parameter name="host" type="STRING?" />
      <input-parameter name="objectIdValue" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.monitor">
    <method name="ids" description="apoc.monitor.ids() returns the object ids in use for this neo4j instance" type="Procedure" release="APOC Full">
      <output-parameter name="nodeIds" type="INTEGER?" />
      <output-parameter name="propIds" type="INTEGER?" />
      <output-parameter name="relIds" type="INTEGER?" />
      <output-parameter name="relTypeIds" type="INTEGER?" />
    </method>
    <method name="kernel" description="apoc.monitor.kernel() returns informations about the neo4j kernel" type="Procedure" release="APOC Full">
      <output-parameter name="databaseName" type="STRING?" />
      <output-parameter name="kernelStartTime" type="STRING?" />
      <output-parameter name="kernelVersion" type="STRING?" />
      <output-parameter name="readOnly" type="BOOLEAN?" />
      <output-parameter name="storeCreationDate" type="STRING?" />
      <output-parameter name="storeId" type="STRING?" />
      <output-parameter name="storeLogVersion" type="INTEGER?" />
    </method>
    <method name="store" description="apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store" type="Procedure" release="APOC Full">
      <output-parameter name="arrayStoreSize" type="INTEGER?" />
      <output-parameter name="logSize" type="INTEGER?" />
      <output-parameter name="nodeStoreSize" type="INTEGER?" />
      <output-parameter name="propStoreSize" type="INTEGER?" />
      <output-parameter name="relStoreSize" type="INTEGER?" />
      <output-parameter name="stringStoreSize" type="INTEGER?" />
      <output-parameter name="totalStoreSize" type="INTEGER?" />
    </method>
    <method name="tx" description="apoc.monitor.tx() returns informations about the neo4j transaction manager" type="Procedure" release="APOC Full">
      <output-parameter name="currentOpenedTx" type="INTEGER?" />
      <output-parameter name="lastTxId" type="INTEGER?" />
      <output-parameter name="peakTx" type="INTEGER?" />
      <output-parameter name="rolledBackTx" type="INTEGER?" />
      <output-parameter name="totalOpenedTx" type="INTEGER?" />
      <output-parameter name="totalTx" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.neighbors">
    <method name="athop" description="apoc.neighbors.athop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '&gt;' or '&lt;' for all outgoing or incoming relationships" type="Procedure" release="APOC Core">
      <input-parameter name="distance" type="INTEGER?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="byhop" description="apoc.neighbors.byhop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '&gt;' or '&lt;' for all outgoing or incoming relationships" type="Procedure" release="APOC Core">
      <input-parameter name="distance" type="INTEGER?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="nodes" type="LIST? OF NODE?" />
    </method>
    <method name="tohop" description="apoc.neighbors.tohop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern up to a certain distance, can use '&gt;' or '&lt;' for all outgoing or incoming relationships" type="Procedure" release="APOC Core">
      <input-parameter name="distance" type="INTEGER?" />
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="node" type="NODE?" />
    </method>
  </namespace>
  <namespace name="apoc.neighbors.athop" />
  <namespace name="apoc.neighbors.byhop" />
  <namespace name="apoc.neighbors.tohop" />
  <namespace name="apoc.nlp.aws.entities" />
  <namespace name="apoc.nlp.aws.keyPhrases" />
  <namespace name="apoc.nlp.aws.sentiment" />
  <namespace name="apoc.nlp.azure.entities" />
  <namespace name="apoc.nlp.azure.keyPhrases" />
  <namespace name="apoc.nlp.azure.sentiment" />
  <namespace name="apoc.nlp.gcp.classify" />
  <namespace name="apoc.nlp.gcp.entities" />
  <namespace name="apoc.node">
    <method name="degree" description="apoc.node.degree(node, rel-direction-pattern) - returns total degrees of the given relationships in the pattern, can use '&gt;' or '&lt;' for all outgoing or incoming relationships" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="id" description="returns id for (virtual) nodes" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="labels" description="returns labels for (virtual) nodes" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
  </namespace>
  <namespace name="apoc.node.degree">
    <method name="in" description="apoc.node.degree.in(node, relationshipName) - returns total number number of incoming relationships" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="out" description="apoc.node.degree.out(node, relationshipName) - returns total number number of outgoing relationships" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.node.relationship" />
  <namespace name="apoc.node.relationships">
    <method name="exist" description="apoc.node.relationships.exist(node, rel-direction-pattern) - returns a map with rel-pattern, boolean for the given relationship patterns" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.nodes">
    <method name="collapse" description="apoc.nodes.collapse([nodes…​],[{properties:'overwrite' or 'discard' or 'combine'}]) yield from, rel, to merge nodes onto first in list" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="from" type="NODE?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
      <output-parameter name="to" type="NODE?" />
    </method>
    <method name="connected" description="apoc.nodes.connected(start, end, rel-direction-pattern) - returns true when the node is connected to the other node, optimized for dense nodes" type="Function" release="APOC Core">
      <input-parameter name="start" type="NODE?" />
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="cycles" description="CALL apoc.nodes.cycles([nodes], $config) - Detect all path cycles from node list" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="group" description="No documentation available." type="Procedure" release="APOC Core">
      <input-parameter name="aggregations" type="LIST? OF MAP?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="groupByProperties" type="LIST? OF STRING?" />
      <input-parameter name="labels" type="LIST? OF STRING?" />
      <output-parameter name="node" type="NODE?" />
      <output-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="relationship" type="RELATIONSHIP?" />
      <output-parameter name="relationships" type="LIST? OF RELATIONSHIP?" />
    </method>
    <method name="isDense" description="apoc.nodes.isDense(node) - returns true if it is a dense node" type="Function" release="APOC Core">
      <input-parameter name="node" type="NODE?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="link" description="apoc.nodes.link([nodes],'REL_TYPE', conf) - creates a linked list of nodes from first to last" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="type" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.nodes.relationship" />
  <namespace name="apoc.nodes.relationships" />
  <namespace name="apoc.number">
    <method name="arabicToRoman" description="apoc.number.arabicToRoman(number)  | convert arabic numbers to roman" type="Function" release="APOC Core">
      <input-parameter name="number" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="parseFloat" description="apoc.number.parseFloat(text)  | parse a text using the default system pattern and language to produce a double" type="Function" release="APOC Core">
      <input-parameter name="lang" type="STRING?" />
      <input-parameter name="pattern" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="parseInt" description="apoc.number.parseInt(text)  | parse a text using the default system pattern and language to produce a long" type="Function" release="APOC Core">
      <input-parameter name="lang" type="STRING?" />
      <input-parameter name="pattern" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="romanToArabic" description="apoc.number.romanToArabic(romanNumber)  | convert roman numbers to arabic" type="Function" release="APOC Core">
      <input-parameter name="romanNumber" type="STRING?" />
      <output-parameter name="Return Value" type="NUMBER?" />
    </method>
  </namespace>
  <namespace name="apoc.number.exact">
    <method name="div" description="apoc.number.exact.div(stringA,stringB,[prec],[roundingModel]) - return the division’s result of two large numbers" type="Function" release="APOC Core">
      <input-parameter name="precision" type="INTEGER?" />
      <input-parameter name="roundingMode" type="STRING?" />
      <input-parameter name="stringA" type="STRING?" />
      <input-parameter name="stringB" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="mul" description="apoc.number.exact.mul(stringA,stringB,[prec],[roundingModel]) - return the multiplication’s result of two large numbers" type="Function" release="APOC Core">
      <input-parameter name="precision" type="INTEGER?" />
      <input-parameter name="roundingMode" type="STRING?" />
      <input-parameter name="stringA" type="STRING?" />
      <input-parameter name="stringB" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sub" description="apoc.number.exact.sub(stringA,stringB) - return the substraction’s of two large numbers" type="Function" release="APOC Core">
      <input-parameter name="stringA" type="STRING?" />
      <input-parameter name="stringB" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toExact" description="apoc.number.exact.toExact(number) - return the exact value" type="Function" release="APOC Core">
      <input-parameter name="number" type="INTEGER?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.path">
    <method name="combine" description="apoc.path.combine(path1, path2) - combines the paths into one if the connecting node matches" type="Function" release="APOC Core">
      <input-parameter name="first" type="PATH?" />
      <input-parameter name="second" type="PATH?" />
      <output-parameter name="Return Value" type="PATH?" />
    </method>
    <method name="create" description="apoc.path.create(startNode,[rels]) - creates a path instance of the given elements" type="Function" release="APOC Core">
      <input-parameter name="rels" type="LIST? OF RELATIONSHIP?" />
      <input-parameter name="startNode" type="NODE?" />
      <output-parameter name="Return Value" type="PATH?" />
    </method>
    <method name="expand" description="apoc.path.expand(startNode &lt;id&gt;|Node|list, 'TYPE|TYPE_OUT&gt;|&lt;TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters" type="Procedure" release="APOC Core">
      <input-parameter name="labelFilter" type="STRING?" />
      <input-parameter name="maxLevel" type="INTEGER?" />
      <input-parameter name="minLevel" type="INTEGER?" />
      <input-parameter name="relationshipFilter" type="STRING?" />
      <input-parameter name="start" type="ANY?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="expandConfig" description="apoc.path.expandConfig(startNode &lt;id&gt;|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters." type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="start" type="ANY?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="spanningTree" description="apoc.path.spanningTree(startNode &lt;id&gt;|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="start" type="ANY?" />
      <output-parameter name="path" type="PATH?" />
    </method>
    <method name="subgraphAll" description="apoc.path.subgraphAll(startNode &lt;id&gt;|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield nodes, relationships - expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="start" type="ANY?" />
      <output-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="relationships" type="LIST? OF RELATIONSHIP?" />
    </method>
    <method name="subgraphNodes" description="apoc.path.subgraphNodes(startNode &lt;id&gt;|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="start" type="ANY?" />
      <output-parameter name="node" type="NODE?" />
    </method>
  </namespace>
  <namespace name="apoc.periodic">
    <method name="cancel" description="apoc.periodic.cancel(name) - cancel job with the given name" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <output-parameter name="cancelled" type="BOOLEAN?" />
      <output-parameter name="delay" type="INTEGER?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="rate" type="INTEGER?" />
    </method>
    <method name="commit" description="apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0" type="Procedure" release="APOC Core">
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="batchErrors" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="commitErrors" type="MAP?" />
      <output-parameter name="executions" type="INTEGER?" />
      <output-parameter name="failedBatches" type="INTEGER?" />
      <output-parameter name="failedCommits" type="INTEGER?" />
      <output-parameter name="runtime" type="INTEGER?" />
      <output-parameter name="updates" type="INTEGER?" />
      <output-parameter name="wasTerminated" type="BOOLEAN?" />
    </method>
    <method name="countdown" description="apoc.periodic.countdown('name',statement,repeat-rate-in-seconds) creates a background job that will repeatedly execute the given Cypher statement until it returns 0." type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="rate" type="INTEGER?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="cancelled" type="BOOLEAN?" />
      <output-parameter name="delay" type="INTEGER?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="rate" type="INTEGER?" />
    </method>
    <method name="iterate" description="apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="cypherAction" type="STRING?" />
      <input-parameter name="cypherIterate" type="STRING?" />
      <output-parameter name="batch" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="committedOperations" type="INTEGER?" />
      <output-parameter name="errorMessages" type="MAP?" />
      <output-parameter name="failedBatches" type="INTEGER?" />
      <output-parameter name="failedOperations" type="INTEGER?" />
      <output-parameter name="failedParams" type="MAP?" />
      <output-parameter name="operations" type="MAP?" />
      <output-parameter name="retries" type="INTEGER?" />
      <output-parameter name="timeTaken" type="INTEGER?" />
      <output-parameter name="total" type="INTEGER?" />
      <output-parameter name="updateStatistics" type="MAP?" />
      <output-parameter name="wasTerminated" type="BOOLEAN?" />
    </method>
    <method name="repeat" description="apoc.periodic.repeat('name',statement,repeat-rate-in-seconds, config) submit a repeatedly-called background query. The parameter 'config' is optional and can contain a 'params' entry usable in nested Cypher statement." type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="rate" type="INTEGER?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="cancelled" type="BOOLEAN?" />
      <output-parameter name="delay" type="INTEGER?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="rate" type="INTEGER?" />
    </method>
    <method name="rock_n_roll" description="apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement’s results in a separate thread. Returns number of batches and total processed rows" type="Procedure" release="APOC Full">
      <input-parameter name="batchSize" type="INTEGER?" />
      <input-parameter name="cypherAction" type="STRING?" />
      <input-parameter name="cypherIterate" type="STRING?" />
      <output-parameter name="batch" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="committedOperations" type="INTEGER?" />
      <output-parameter name="errorMessages" type="MAP?" />
      <output-parameter name="failedBatches" type="INTEGER?" />
      <output-parameter name="failedOperations" type="INTEGER?" />
      <output-parameter name="failedParams" type="MAP?" />
      <output-parameter name="operations" type="MAP?" />
      <output-parameter name="retries" type="INTEGER?" />
      <output-parameter name="timeTaken" type="INTEGER?" />
      <output-parameter name="total" type="INTEGER?" />
      <output-parameter name="updateStatistics" type="MAP?" />
      <output-parameter name="wasTerminated" type="BOOLEAN?" />
    </method>
    <method name="rock_n_roll_while" description="apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement’s results in a separate thread. Returns number of batches and total processed rows" type="Procedure" release="APOC Full">
      <input-parameter name="batchSize" type="INTEGER?" />
      <input-parameter name="cypherAction" type="STRING?" />
      <input-parameter name="cypherIterate" type="STRING?" />
      <input-parameter name="cypherLoop" type="STRING?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="loop" type="ANY?" />
      <output-parameter name="total" type="INTEGER?" />
    </method>
    <method name="submit" description="apoc.periodic.submit('name',statement,params) - creates a background job which executes a Cypher statement once. The parameter 'params' is optional and can contain query parameters for the Cypher statement" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <input-parameter name="params" type="MAP?" />
      <input-parameter name="statement" type="STRING?" />
      <output-parameter name="cancelled" type="BOOLEAN?" />
      <output-parameter name="delay" type="INTEGER?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="rate" type="INTEGER?" />
    </method>
    <method name="truncate" description="apoc.periodic.truncate({config}) - removes all entities (and optionally indexes and constraints) from db using the apoc.periodic.iterate under the hood" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.redis">
    <method name="configGet" description="apoc.redis.configGet(uri, parameter, {config}) | Execute the 'CONFIG GET parameter' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="parameter" type="STRING?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="configSet" description="apoc.redis.configSet(uri, parameter, {config}) | Execute the 'CONFIG SET parameter value' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="parameter" type="STRING?" />
      <input-parameter name="uri" type="STRING?" />
      <input-parameter name="value" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="copy" description="apoc.redis.copy(uri, source, destination, {config}) | Execute the 'COPY source destination' command and returns true if source was copied and false otherwise" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="destination" type="ANY?" />
      <input-parameter name="source" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="BOOLEAN?" />
    </method>
    <method name="eval" description="apoc.redis.eval(uri, script, outputType, keys, values, {config}) | Execute the 'EVAL script' command. In the parameters provided to the procedure, keys are bound to the KEYS[n] like special array of the Lua script and values are bound to the ARGV[n] like special array of the Lua script." type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="keys" type="LIST? OF ANY?" />
      <input-parameter name="outputType" type="STRING?" />
      <input-parameter name="script" type="STRING?" />
      <input-parameter name="uri" type="STRING?" />
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="getSet" description="apoc.redis.getSet(uri, key, value, {config}) | Execute the 'SET key value' command and return old value stored (or null if did not exists)" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="hdel" description="apoc.redis.hdel(uri, key, fields, {config}) | Execute the 'HDEL key fields' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="fields" type="LIST? OF ANY?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="hexists" description="apoc.redis.hexists(uri, key, field, {config}) | Execute the 'HEXISTS key field' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="field" type="ANY?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="BOOLEAN?" />
    </method>
    <method name="hget" description="apoc.redis.hget(uri, key, field, {config}) | Execute the 'HGET key field' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="field" type="ANY?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="hgetall" description="apoc.redis.hgetall(uri, key, {config}) | Execute the 'HGETALL key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="MAP?" />
    </method>
    <method name="hincrby" description="apoc.redis.hincrby(uri, key, field, amount, {config}) | Execute the 'HINCRBY key field amount' command" type="Procedure" release="APOC Full">
      <input-parameter name="amount" type="INTEGER?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="field" type="ANY?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="hset" description="apoc.redis.hset(uri, key, field, value, {config}) | Execute the 'HSET key field value' command and returns true if it is a new field in the hash or false if the field already exists" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="field" type="ANY?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="value" type="BOOLEAN?" />
    </method>
    <method name="incrby" description="apoc.redis.incrby(uri, key, amount, {config}) | Execute the 'INCRBY key increment' command" type="Procedure" release="APOC Full">
      <input-parameter name="amount" type="INTEGER?" />
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="lrange" description="apoc.redis.lrange(uri, key, start, stop, {config}) | Execute the 'LRANGE key start stop' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="start" type="INTEGER?" />
      <input-parameter name="stop" type="INTEGER?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
    <method name="persist" description="apoc.redis.persist(uri, key, {config}) | Execute the 'PERSIST key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="BOOLEAN?" />
    </method>
    <method name="pexpire" description="apoc.redis.pexpire(uri, key, time, isExpireAt {config}) | Execute the 'PEXPIRE key time' command, or the 'PEPXPIREAT' if isExpireAt=true" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="isExpireAt" type="BOOLEAN?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="time" type="INTEGER?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="BOOLEAN?" />
    </method>
    <method name="pop" description="apoc.redis.pop(uri, key, {config}) | Execute the 'LPOP key' command, or the 'RPOP' if config right=true (default)" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="pttl" description="apoc.redis.pttl(uri, key, {config}) | Execute the 'PTTL key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="push" description="apoc.redis.push(uri, key, values, {config}) | Execute the 'LPUSH key field values' command, or the 'RPUSH' if config right=true (default)" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <input-parameter name="value" type="LIST? OF ANY?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="sadd" description="apoc.redis.sadd(uri, key, members, {config}) | Execute the 'SADD key members' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="members" type="LIST? OF ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="scard" description="apoc.redis.scard(uri, key, {config}) | Execute the 'SCARD key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="smembers" description="apoc.redis.smembers(uri, key, {config}) | Execute the 'SMEMBERS key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
    <method name="spop" description="apoc.redis.spop(uri, key, {config}) | Execute the 'SPOP key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
    <method name="sunion" description="apoc.redis.sunion(uri, keys, {config}) | Execute the 'SUNION keys' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="keys" type="LIST? OF ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
    <method name="zadd" description="apoc.redis.zadd(uri, keys, scoresAndMembers, {config}) | Execute the 'ZADD key scoresAndMembers' command, where scoresAndMembers is a list of score,member,score,member,…​" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <input-parameter name="value" type="LIST? OF ANY?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="zcard" description="apoc.redis.zcard(uri, key, {config}) | Execute the 'ZCARD key' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
    <method name="zrangebyscore" description="apoc.redis.zrangebyscore(uri, key, min, max, {config}) | Execute the 'ZRANGEBYSCORE key min max' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="max" type="INTEGER?" />
      <input-parameter name="min" type="INTEGER?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
    <method name="zrem" description="apoc.redis.zrem(uri, key, members, {config}) | Execute the 'ZREM key members' command" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="key" type="ANY?" />
      <input-parameter name="members" type="LIST? OF ANY?" />
      <input-parameter name="uri" type="STRING?" />
      <output-parameter name="value" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.refactor">
    <method name="categorize" description="apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it" type="Procedure" release="APOC Core">
      <input-parameter name="batchSize" type="INTEGER?" />
      <input-parameter name="copiedKeys" type="LIST? OF STRING?" />
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="outgoing" type="BOOLEAN?" />
      <input-parameter name="sourceKey" type="STRING?" />
      <input-parameter name="targetKey" type="STRING?" />
      <input-parameter name="type" type="STRING?" />
    </method>
    <method name="cloneNodes" description="apoc.refactor.cloneNodes([node1,node2,…​]) clone nodes with their labels and properties" type="Procedure" release="APOC Core">
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="skipProperties" type="LIST? OF STRING?" />
      <input-parameter name="withRelationships" type="BOOLEAN?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="NODE?" />
    </method>
    <method name="cloneNodesWithRelationships" description="apoc.refactor.cloneNodesWithRelationships([node1,node2,…​]) clone nodes with their labels, properties and relationships" type="Procedure" release="APOC Core">
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="NODE?" />
    </method>
    <method name="cloneSubgraph" description="apoc.refactor.cloneSubgraph([node1,node2,…​], [rel1,rel2,…​]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin." type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="rels" type="LIST? OF RELATIONSHIP?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="NODE?" />
    </method>
    <method name="cloneSubgraphFromPaths" description="apoc.refactor.cloneSubgraphFromPaths([path1, path2, …​], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin." type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="paths" type="LIST? OF PATH?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="NODE?" />
    </method>
    <method name="collapseNode" description="apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship" type="Procedure" release="APOC Core">
      <input-parameter name="nodes" type="ANY?" />
      <input-parameter name="type" type="STRING?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="RELATIONSHIP?" />
    </method>
    <method name="deleteAndReconnect" description="apoc.refactor.deleteAndReconnect([pathLinkedList], [nodesToRemove], {config}) - Removes some nodes from a linked list" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="path" type="PATH?" />
      <output-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="relationships" type="LIST? OF RELATIONSHIP?" />
    </method>
    <method name="extractNode" description="apoc.refactor.extractNode([rel1,rel2,…​], [labels],'OUT','IN') extract node from relationships" type="Procedure" release="APOC Core">
      <input-parameter name="inType" type="STRING?" />
      <input-parameter name="labels" type="LIST? OF STRING?" />
      <input-parameter name="outType" type="STRING?" />
      <input-parameter name="relationships" type="ANY?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="NODE?" />
    </method>
    <method name="invert" description="apoc.refactor.invert(rel) inverts relationship direction" type="Procedure" release="APOC Core">
      <input-parameter name="relationship" type="RELATIONSHIP?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="RELATIONSHIP?" />
    </method>
    <method name="mergeNodes" description="apoc.refactor.mergeNodes([node1,node2],[{properties:'overwrite' or 'discard' or 'combine'}]) merge nodes onto first in list" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="mergeRelationships" description="apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="rels" type="LIST? OF RELATIONSHIP?" />
      <output-parameter name="rel" type="RELATIONSHIP?" />
    </method>
    <method name="normalizeAsBoolean" description="apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean" type="Procedure" release="APOC Core">
      <input-parameter name="entity" type="ANY?" />
      <input-parameter name="false_values" type="LIST? OF ANY?" />
      <input-parameter name="propertyKey" type="STRING?" />
      <input-parameter name="true_values" type="LIST? OF ANY?" />
    </method>
    <method name="setType" description="apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type" type="Procedure" release="APOC Core">
      <input-parameter name="newType" type="STRING?" />
      <input-parameter name="relationship" type="RELATIONSHIP?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="RELATIONSHIP?" />
    </method>
    <method name="to" description="No documentation available." type="Procedure" release="APOC Core">
      <input-parameter name="newNode" type="NODE?" />
      <input-parameter name="relationship" type="RELATIONSHIP?" />
      <output-parameter name="error" type="STRING?" />
      <output-parameter name="input" type="INTEGER?" />
      <output-parameter name="output" type="RELATIONSHIP?" />
    </method>
  </namespace>
  <namespace name="apoc.refactor.rename">
    <method name="label" description="apoc.refactor.rename.label(oldLabel, newLabel, [nodes]) | rename a label from 'oldLabel' to 'newLabel' for all nodes. If 'nodes' is provided renaming is applied to this set only" type="Procedure" release="APOC Core">
      <input-parameter name="newLabel" type="STRING?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="oldLabel" type="STRING?" />
      <output-parameter name="batch" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="committedOperations" type="INTEGER?" />
      <output-parameter name="constraints" type="LIST? OF STRING?" />
      <output-parameter name="errorMessages" type="MAP?" />
      <output-parameter name="failedBatches" type="INTEGER?" />
      <output-parameter name="failedOperations" type="INTEGER?" />
      <output-parameter name="indexes" type="LIST? OF STRING?" />
      <output-parameter name="operations" type="MAP?" />
      <output-parameter name="retries" type="INTEGER?" />
      <output-parameter name="timeTaken" type="INTEGER?" />
      <output-parameter name="total" type="INTEGER?" />
    </method>
    <method name="nodeProperty" description="apoc.refactor.rename.nodeProperty(oldName, newName, [nodes], {config}) | rename all node’s property from 'oldName' to 'newName'. If 'nodes' is provided renaming is applied to this set only" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="newName" type="STRING?" />
      <input-parameter name="nodes" type="LIST? OF NODE?" />
      <input-parameter name="oldName" type="STRING?" />
      <output-parameter name="batch" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="committedOperations" type="INTEGER?" />
      <output-parameter name="constraints" type="LIST? OF STRING?" />
      <output-parameter name="errorMessages" type="MAP?" />
      <output-parameter name="failedBatches" type="INTEGER?" />
      <output-parameter name="failedOperations" type="INTEGER?" />
      <output-parameter name="indexes" type="LIST? OF STRING?" />
      <output-parameter name="operations" type="MAP?" />
      <output-parameter name="retries" type="INTEGER?" />
      <output-parameter name="timeTaken" type="INTEGER?" />
      <output-parameter name="total" type="INTEGER?" />
    </method>
    <method name="typeProperty" description="apoc.refactor.rename.typeProperty(oldName, newName, [rels], {config}) | rename all relationship’s property from 'oldName' to 'newName'. If 'rels' is provided renaming is applied to this set only" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="newName" type="STRING?" />
      <input-parameter name="oldName" type="STRING?" />
      <input-parameter name="rels" type="LIST? OF RELATIONSHIP?" />
      <output-parameter name="batch" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="committedOperations" type="INTEGER?" />
      <output-parameter name="constraints" type="LIST? OF STRING?" />
      <output-parameter name="errorMessages" type="MAP?" />
      <output-parameter name="failedBatches" type="INTEGER?" />
      <output-parameter name="failedOperations" type="INTEGER?" />
      <output-parameter name="indexes" type="LIST? OF STRING?" />
      <output-parameter name="operations" type="MAP?" />
      <output-parameter name="retries" type="INTEGER?" />
      <output-parameter name="timeTaken" type="INTEGER?" />
      <output-parameter name="total" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.rel">
    <method name="endNode" description="returns endNode for (virtual) relationships" type="Function" release="APOC Core">
      <input-parameter name="rel" type="RELATIONSHIP?" />
      <output-parameter name="Return Value" type="NODE?" />
    </method>
    <method name="startNode" description="returns startNode for (virtual) relationships" type="Function" release="APOC Core">
      <input-parameter name="rel" type="RELATIONSHIP?" />
      <output-parameter name="Return Value" type="NODE?" />
    </method>
  </namespace>
  <namespace name="apoc.schema">
    <method name="assert" description="apoc.schema.assert({indexLabel:, …​}, {constraintLabel:[constraintKeys], …​}, dropExisting : true) yield label, key, keys, unique, action - drops all other existing indexes and constraints when dropExisting is true (default is true), and asserts that at the end of the operation the given indexes and unique constraints are there, each label:key pair is considered one constraint/label. Non-constraint indexes can define compound indexes with label:[key1,key2…​] pairings." type="Procedure" release="APOC Core">
      <input-parameter name="constraints" type="MAP?" />
      <input-parameter name="dropExisting" type="BOOLEAN?" />
      <input-parameter name="indexes" type="MAP?" />
      <output-parameter name="action" type="STRING?" />
      <output-parameter name="key" type="STRING?" />
      <output-parameter name="keys" type="LIST? OF STRING?" />
      <output-parameter name="label" type="ANY?" />
      <output-parameter name="unique" type="BOOLEAN?" />
    </method>
    <method name="relationships" description="CALL apoc.schema.relationships([config]) yield name, startLabel, type, endLabel, properties, status" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="properties" type="LIST? OF STRING?" />
      <output-parameter name="status" type="STRING?" />
      <output-parameter name="type" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.schema.node">
    <method name="constraintExists" description="RETURN apoc.schema.node.constraintExists(labelName, propertyNames)" type="Function" release="APOC Core">
      <input-parameter name="labelName" type="STRING?" />
      <input-parameter name="propertyName" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="indexExists" description="RETURN apoc.schema.node.indexExists(labelName, propertyNames)" type="Function" release="APOC Core">
      <input-parameter name="labelName" type="STRING?" />
      <input-parameter name="propertyName" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
  </namespace>
  <namespace name="apoc.schema.properties">
    <method name="distinct" description="apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key" type="Procedure" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="label" type="STRING?" />
      <output-parameter name="value" type="LIST? OF ANY?" />
    </method>
    <method name="distinctCount" description="apoc.schema.properties.distinctCount([label], [key]) YIELD label, key, value, count - quickly returns all distinct values and counts for a given key" type="Procedure" release="APOC Core">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="label" type="STRING?" />
      <output-parameter name="count" type="INTEGER?" />
      <output-parameter name="key" type="STRING?" />
      <output-parameter name="label" type="STRING?" />
      <output-parameter name="value" type="ANY?" />
    </method>
  </namespace>
  <namespace name="apoc.schema.relationship" />
  <namespace name="apoc.scoring">
    <method name="existence" description="apoc.scoring.existence(5, true) returns the provided score if true, 0 if false" type="Function" release="APOC Core">
      <input-parameter name="exists" type="BOOLEAN?" />
      <input-parameter name="score" type="INTEGER?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="pareto" description="apoc.scoring.pareto(10, 20, 100, 11) applies a Pareto scoring function over the inputs" type="Function" release="APOC Core">
      <input-parameter name="eightyPercentValue" type="INTEGER?" />
      <input-parameter name="maximumValue" type="INTEGER?" />
      <input-parameter name="minimumThreshold" type="INTEGER?" />
      <input-parameter name="score" type="INTEGER?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
  </namespace>
  <namespace name="apoc.search">
    <method name="multiSearchReduced" description="Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record." type="Procedure" release="APOC Core">
      <input-parameter name="LabelPropertyMap" type="ANY?" />
      <input-parameter name="operator" type="STRING?" />
      <input-parameter name="value" type="STRING?" />
      <output-parameter name="id" type="INTEGER?" />
      <output-parameter name="labels" type="LIST? OF STRING?" />
      <output-parameter name="values" type="MAP?" />
    </method>
    <method name="nodeAll" description="Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches." type="Procedure" release="APOC Core">
      <input-parameter name="LabelPropertyMap" type="ANY?" />
      <input-parameter name="operator" type="STRING?" />
      <input-parameter name="value" type="STRING?" />
      <output-parameter name="node" type="NODE?" />
    </method>
    <method name="nodeAllReduced" description="Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH / = / &lt;&gt; / &lt; / &gt; …​, value ). All 'hits' are returned." type="Procedure" release="APOC Core">
      <input-parameter name="LabelPropertyMap" type="ANY?" />
      <input-parameter name="operator" type="STRING?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="id" type="INTEGER?" />
      <output-parameter name="labels" type="LIST? OF STRING?" />
      <output-parameter name="values" type="MAP?" />
    </method>
    <method name="nodeReduced" description="Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record." type="Procedure" release="APOC Core">
      <input-parameter name="LabelPropertyMap" type="ANY?" />
      <input-parameter name="operator" type="STRING?" />
      <input-parameter name="value" type="STRING?" />
      <output-parameter name="id" type="INTEGER?" />
      <output-parameter name="labels" type="LIST? OF STRING?" />
      <output-parameter name="values" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.spatial">
    <method name="geocode" description="apoc.spatial.geocode('address', maxResults, quotaException, $config) YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="location" type="STRING?" />
      <input-parameter name="maxResults" type="INTEGER?" />
      <input-parameter name="quotaException" type="BOOLEAN?" />
      <output-parameter name="data" type="MAP?" />
      <output-parameter name="description" type="STRING?" />
      <output-parameter name="latitude" type="FLOAT?" />
      <output-parameter name="location" type="MAP?" />
      <output-parameter name="longitude" type="FLOAT?" />
    </method>
    <method name="geocodeOnce" description="apoc.spatial.geocodeOnce('address', $config) YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="location" type="STRING?" />
      <output-parameter name="data" type="MAP?" />
      <output-parameter name="description" type="STRING?" />
      <output-parameter name="latitude" type="FLOAT?" />
      <output-parameter name="location" type="MAP?" />
      <output-parameter name="longitude" type="FLOAT?" />
    </method>
    <method name="reverseGeocode" description="apoc.spatial.reverseGeocode(latitude,longitude, quotaException, $config) YIELD location, latitude, longitude, description - look up address from latitude and longitude from a geocoding service (the default one is OpenStreetMap)" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="latitude" type="FLOAT?" />
      <input-parameter name="longitude" type="FLOAT?" />
      <input-parameter name="quotaException" type="BOOLEAN?" />
      <output-parameter name="data" type="MAP?" />
      <output-parameter name="description" type="STRING?" />
      <output-parameter name="latitude" type="FLOAT?" />
      <output-parameter name="location" type="MAP?" />
      <output-parameter name="longitude" type="FLOAT?" />
    </method>
    <method name="sortByDistance" description="apoc.spatial.sortByDistance(List&lt;Path&gt;) sort the given paths based on the geo informations (lat/long) in ascending order" type="Procedure" release="APOC Core">
      <input-parameter name="paths" type="LIST? OF PATH?" />
      <output-parameter name="distance" type="FLOAT?" />
      <output-parameter name="path" type="PATH?" />
    </method>
  </namespace>
  <namespace name="apoc.static">
    <method name="getAll" description="apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.&lt;prefix&gt;.*) or server lifetime storage" type="Function" release="APOC Full">
      <input-parameter name="prefix" type="STRING?" />
      <output-parameter name="Return Value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.stats">
    <method name="degrees" description="No documentation available." type="Procedure" release="APOC Core">
      <input-parameter name="types" type="STRING?" />
      <output-parameter name="direction" type="STRING?" />
      <output-parameter name="max" type="INTEGER?" />
      <output-parameter name="mean" type="FLOAT?" />
      <output-parameter name="min" type="INTEGER?" />
      <output-parameter name="p50" type="INTEGER?" />
      <output-parameter name="p75" type="INTEGER?" />
      <output-parameter name="p90" type="INTEGER?" />
      <output-parameter name="p95" type="INTEGER?" />
      <output-parameter name="p99" type="INTEGER?" />
      <output-parameter name="p999" type="INTEGER?" />
      <output-parameter name="total" type="INTEGER?" />
      <output-parameter name="type" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.systemdb" />
  <namespace name="apoc.systemdb.export">
    <method name="metadata" description="No documentation available." type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <output-parameter name="batches" type="INTEGER?" />
      <output-parameter name="batchSize" type="INTEGER?" />
      <output-parameter name="data" type="STRING?" />
      <output-parameter name="done" type="BOOLEAN?" />
      <output-parameter name="file" type="STRING?" />
      <output-parameter name="format" type="STRING?" />
      <output-parameter name="nodes" type="INTEGER?" />
      <output-parameter name="properties" type="INTEGER?" />
      <output-parameter name="relationships" type="INTEGER?" />
      <output-parameter name="rows" type="INTEGER?" />
      <output-parameter name="source" type="STRING?" />
      <output-parameter name="time" type="INTEGER?" />
    </method>
  </namespace>
  <namespace name="apoc.temporal">
    <method name="formatDuration" description="apoc.temporal.formatDuration(input, format) | Format a Duration" type="Function" release="APOC Core">
      <input-parameter name="format" type="STRING?" />
      <input-parameter name="input" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toZonedTemporal" description="apoc.temporal.toZonedTemporal('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') parse date string using the specified format to specified timezone" type="Function" release="APOC Core">
      <input-parameter name="format" type="STRING?" />
      <input-parameter name="time" type="STRING?" />
      <input-parameter name="timezone" type="STRING?" />
      <output-parameter name="Return Value" type="DATETIME?" />
    </method>
  </namespace>
  <namespace name="apoc.text">
    <method name="base64Decode" description="apoc.text.base64Decode(text) YIELD value - Decode Base64 encoded string" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="base64Encode" description="apoc.text.base64Encode(text) YIELD value - Encode a string with Base64" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="base64UrlDecode" description="apoc.text.base64UrlDecode(url) YIELD value - Decode Base64 encoded url" type="Function" release="APOC Core">
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="base64UrlEncode" description="apoc.text.base64UrlEncode(text) YIELD value - Encode a url with Base64" type="Function" release="APOC Core">
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="byteCount" description="apoc.text.byteCount(text,[charset]) - return size of text in bytes" type="Function" release="APOC Core">
      <input-parameter name="charset" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="bytes" description="apoc.text.bytes(text,[charset]) - return bytes of the text" type="Function" release="APOC Core">
      <input-parameter name="charset" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="camelCase" description="apoc.text.camelCase(text) YIELD value - Convert a string to camelCase" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="capitalize" description="apoc.text.capitalize(text) YIELD value - capitalise the first letter of the word" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="capitalizeAll" description="apoc.text.capitalizeAll(text) YIELD value - capitalise the first letter of every word in the text" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="charAt" description="apoc.text.charAt(text, index) - the decimal value of the character at the given index" type="Function" release="APOC Core">
      <input-parameter name="index" type="INTEGER?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="code" description="apoc.text.code(codepoint) - Returns the unicode character of the given codepoint" type="Function" release="APOC Core">
      <input-parameter name="codepoint" type="INTEGER?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="compareCleaned" description="apoc.text.compareCleaned(text1, text2) - compare the given strings stripped of everything except alpha numeric characters converted to lower case." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="decapitalize" description="apoc.text.decapitalize(text) YIELD value - decapitalize the first letter of the word" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="decapitalizeAll" description="apoc.text.decapitalizeAll(text) YIELD value - decapitalize the first letter of all words" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="distance" description="apoc.text.distance(text1, text2) - compare the given strings with the Levenshtein distance algorithm." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="doubleMetaphone" description="apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings" type="Procedure" release="APOC Core">
      <input-parameter name="value" type="STRING?" />
    </method>
    <method name="fuzzyMatch" description="apoc.text.fuzzyMatch(text1, text2) - check if 2 words can be matched in a fuzzy way. Depending on the length of the String it will allow more characters that needs to be edited to match the second String." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
    <method name="hammingDistance" description="apoc.text.hammingDistance(text1, text2) - compare the given strings with the Hamming distance algorithm." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="hexCharAt" description="apoc.text.hexCharAt(text, index) - the hex value string of the character at the given index" type="Function" release="APOC Core">
      <input-parameter name="index" type="INTEGER?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="hexValue" description="apoc.text.hexValue(value) - the hex value string of the given number" type="Function" release="APOC Core">
      <input-parameter name="value" type="INTEGER?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="indexesOf" description="apoc.text.indexesOf(text, lookup, from=0, to=-1==len) - finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null." type="Function" release="APOC Core">
      <input-parameter name="from" type="INTEGER?" />
      <input-parameter name="lookup" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <input-parameter name="to" type="INTEGER?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="jaroWinklerDistance" description="apoc.text.jaroWinklerDistance(text1, text2) - compare the given strings with the Jaro-Winkler distance algorithm." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="join" description="apoc.text.join(['text1','text2',…​], delimiter) - join the given strings with the given delimiter." type="Function" release="APOC Core">
      <input-parameter name="delimiter" type="STRING?" />
      <input-parameter name="texts" type="LIST? OF STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="levenshteinDistance" description="apoc.text.levenshteinDistance(text1, text2) - compare the given strings with the Levenshtein distance algorithm." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="INTEGER?" />
    </method>
    <method name="levenshteinSimilarity" description="apoc.text.levenshteinSimilarity(text1, text2) - calculate the similarity (a value within 0 and 1) between two texts." type="Function" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="lpad" description="apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width" type="Function" release="APOC Core">
      <input-parameter name="count" type="INTEGER?" />
      <input-parameter name="delim" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="phonetic" description="apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings" type="Procedure" release="APOC Core">
      <input-parameter name="value" type="STRING?" />
    </method>
    <method name="phoneticDelta" description="apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings" type="Procedure" release="APOC Core">
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="delta" type="INTEGER?" />
      <output-parameter name="phonetic1" type="STRING?" />
      <output-parameter name="phonetic2" type="STRING?" />
    </method>
    <method name="random" description="apoc.text.random(length, valid) YIELD value - generate a random string" type="Function" release="APOC Core">
      <input-parameter name="length" type="INTEGER?" />
      <input-parameter name="valid" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="regexGroups" description="apoc.text.regexGroups(text, regex) - return all matching groups of the regex on the given text." type="Function" release="APOC Core">
      <input-parameter name="regex" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
    </method>
    <method name="regreplace" description="apoc.text.regreplace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement." type="Function" release="APOC Core">
      <input-parameter name="regex" type="STRING?" />
      <input-parameter name="replacement" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="rpad" description="apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width" type="Function" release="APOC Core">
      <input-parameter name="count" type="INTEGER?" />
      <input-parameter name="delim" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="slug" description="apoc.text.slug(text, delim) - slug the text with the given delimiter" type="Function" release="APOC Core">
      <input-parameter name="delim" type="STRING?" />
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="snakeCase" description="apoc.text.snakeCase(text) YIELD value - Convert a string to snake-case" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sorensenDiceSimilarity" description="apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) - compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag" type="Function" release="APOC Core">
      <input-parameter name="languageTag" type="STRING?" />
      <input-parameter name="text1" type="STRING?" />
      <input-parameter name="text2" type="STRING?" />
      <output-parameter name="Return Value" type="FLOAT?" />
    </method>
    <method name="swapCase" description="apoc.text.swapCase(text) YIELD value - Swap the case of a string" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toCypher" description="apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end}) | tries it’s best to convert the value to a cypher-property-string" type="Function" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="value" type="ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="toUpperCase" description="apoc.text.toUpperCase(text) YIELD value - Convert a string to UPPER_CASE" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="upperCamelCase" description="apoc.text.upperCamelCase(text) YIELD value - Convert a string to camelCase" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="urldecode" description="apoc.text.urldecode(text) - return the urldecoded text" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="urlencode" description="apoc.text.urlencode(text) - return the urlencoded text" type="Function" release="APOC Core">
      <input-parameter name="text" type="STRING?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
  </namespace>
  <namespace name="apoc.trigger">
    <method name="nodesByLabel" description="No documentation available." type="Function" release="APOC Full">
      <input-parameter name="label" type="STRING?" />
      <input-parameter name="labelEntries" type="ANY?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
    <method name="pause" description="CALL apoc.trigger.pause(name) | it pauses the trigger" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <output-parameter name="installed" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="params" type="MAP?" />
      <output-parameter name="paused" type="BOOLEAN?" />
      <output-parameter name="query" type="STRING?" />
      <output-parameter name="selector" type="MAP?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
    <method name="propertiesByKey" description="No documentation available." type="Function" release="APOC Full">
      <input-parameter name="key" type="STRING?" />
      <input-parameter name="propertyEntries" type="MAP?" />
      <output-parameter name="Return Value" type="LIST? OF ANY?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
    <method name="resume" description="CALL apoc.trigger.resume(name) | it resumes the paused trigger" type="Procedure" release="APOC Core">
      <input-parameter name="name" type="STRING?" />
      <output-parameter name="installed" type="BOOLEAN?" />
      <output-parameter name="name" type="STRING?" />
      <output-parameter name="params" type="MAP?" />
      <output-parameter name="paused" type="BOOLEAN?" />
      <output-parameter name="query" type="STRING?" />
      <output-parameter name="selector" type="MAP?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
  </namespace>
  <namespace name="apoc.ttl">
    <method name="config" description="No documentation available." type="Function" release="APOC Full">
      <output-parameter name="Return Value" type="MAP?" />
    </method>
  </namespace>
  <namespace name="apoc.util">
    <method name="compress" description="apoc.util.compress(string, {config}) | return a compressed byte[] in various format from a string" type="Function" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="data" type="STRING?" />
      <output-parameter name="Return Value" type="BYTEARRAY?" />
    </method>
    <method name="decompress" description="apoc.util.decompress(compressed, {config}) | return a string from a compressed byte[] in various format" type="Function" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="data" type="BYTEARRAY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="md5" description="apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list. Unsuitable for cryptographic use-cases." type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sha1" description="apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sha256" description="apoc.util.sha256([values]) | computes the sha256 of the concatenation of all string values of the list" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sha384" description="apoc.util.sha384([values]) | computes the sha384 of the concatenation of all string values of the list" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sha512" description="apoc.util.sha512([values]) | computes the sha512 of the concatenation of all string values of the list" type="Function" release="APOC Core">
      <input-parameter name="values" type="LIST? OF ANY?" />
      <output-parameter name="Return Value" type="STRING?" />
    </method>
    <method name="sleep" description="apoc.util.sleep(&lt;duration&gt;) | sleeps for &lt;duration&gt; millis, transaction termination is honored" type="Procedure" release="APOC Core">
      <input-parameter name="duration" type="INTEGER?" />
    </method>
    <method name="validatePredicate" description="apoc.util.validatePredicate(predicate, message, params) | if the predicate yields to true raise an exception else returns true, for use inside WHERE subclauses" type="Function" release="APOC Core">
      <input-parameter name="message" type="STRING?" />
      <input-parameter name="params" type="LIST? OF ANY?" />
      <input-parameter name="predicate" type="BOOLEAN?" />
      <output-parameter name="Return Value" type="BOOLEAN?" />
    </method>
  </namespace>
  <namespace name="apoc.uuid">
    <method name="install" description="CALL apoc.uuid.install(label, {addToExistingNodes: true/false, uuidProperty: 'uuid'}) yield label, installed, properties, batchComputationResult | it will add the uuid transaction handler&#xA;for the provided label and uuidProperty, in case the UUID handler is already present it will be replaced by the new one" type="Procedure" release="APOC Full">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="label" type="STRING?" />
      <output-parameter name="batchComputationResult" type="MAP?" />
      <output-parameter name="installed" type="BOOLEAN?" />
      <output-parameter name="label" type="STRING?" />
      <output-parameter name="properties" type="MAP?" />
      <warning>This procedure is not intended to be used in a cluster environment, and may act unpredictably.</warning>
    </method>
  </namespace>
  <namespace name="apoc.warmup" />
  <namespace name="apoc.xml">
    <method name="import" description="Deprecated by apoc.import.xml" type="Procedure" release="APOC Core">
      <input-parameter name="config" type="MAP?" />
      <input-parameter name="url" type="STRING?" />
      <output-parameter name="node" type="NODE?" />
    </method>
  </namespace>
</apoc>