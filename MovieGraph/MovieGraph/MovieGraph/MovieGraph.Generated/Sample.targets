<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
  </PropertyGroup>

  <UsingTask TaskName="ExecuteCompileCheck" TaskFactory="CodeTaskFactory" AssemblyFile="$(RoslynCodeTaskFactory)" Condition="'$(RoslynCodeTaskFactory)' != ''">
    <ParameterGroup>
      <Message ParameterType="System.String" Required="true" />
      <AssemblyFile ParameterType="System.String" Required="true" />
      <TypeName ParameterType="System.String" Required="true" />
      <MethodName ParameterType="System.String" Required="true" />
      <Argument ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Xml" />
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />      
      <Using Namespace="System.Diagnostics" />
      <Using Namespace="System.Reflection" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
#line 17        

Assembly assembly;

Func<string, Assembly> LoadAssembly = delegate(string filename)
{
  string pdbFilename = Path.ChangeExtension(filename, "pdb");

  byte[] assemblyDllBytes = File.Exists(filename) ? File.ReadAllBytes(filename) : null;
  if (assemblyDllBytes == null || assemblyDllBytes.Length == 0)
    return null;
  
  byte[] assemblyPdbBytes = File.Exists(pdbFilename) ? File.ReadAllBytes(pdbFilename) : null;
    
  return Assembly.Load(assemblyDllBytes, assemblyPdbBytes);
};

ResolveEventHandler handler = delegate(object sender, ResolveEventArgs eventArgs)
{
  string name;
  if (eventArgs.Name.IndexOf(",") > -1)
    name = eventArgs.Name.Substring (0, eventArgs.Name.IndexOf (","));
  else
    name = eventArgs.Name;

  string assemblyPath = Path.Combine(Path.GetDirectoryName(AssemblyFile), name + ".dll");
  if (name.ToLowerInvariant() == "netstandard")
  {
    assemblyPath = Path.GetDirectoryName(AssemblyFile);
    while (assemblyPath != null && assemblyPath != "")
    {
      if (File.Exists(Path.Combine(assemblyPath, @"DLLs\netstandard\framework\netstandard.dll")))
      {
        assemblyPath = Path.Combine(assemblyPath, @"DLLs\netstandard\framework\netstandard.dll");
        break;
      }
      assemblyPath = Path.GetDirectoryName(assemblyPath);
    }
  }
  assembly = LoadAssembly(assemblyPath);
  if (assembly != null && (name.ToLowerInvariant() == "netstandard" || assembly.FullName == eventArgs.Name))
    return assembly;

  Log.LogMessage(MessageImportance.High, string.Format("### Loading FAILED '{0}' ###", assemblyPath));
  if (assembly != null)
  {
    Log.LogMessage(MessageImportance.High, string.Format("### Expected '{0}' actual '{1}' ###", eventArgs.Name, assembly.FullName));
  }
  return null;
};

Stopwatch stopWatch = new Stopwatch();
try
{
  Log.LogMessage(MessageImportance.High, string.Format("### {0} ###", Message));

  AppDomain.CurrentDomain.AssemblyResolve += handler;
  stopWatch.Start();

  assembly = LoadAssembly(AssemblyFile);
  if (assembly == null)
  {
    Log.LogError(string.Format("ExecuteCompileCheck: Assembly '{0}' not found.", AssemblyFile), MessageImportance.High);
  }
  else
  {
    Type type = assembly.GetType(TypeName);
    if (type == null)
    {
      Log.LogError(string.Format("ExecuteCompileCheck: Type '{0}' not found.", TypeName), MessageImportance.High);
    }
    else
    {
      MethodInfo method = type.GetMethod(MethodName);
      if (method == null)
      {
        Log.LogError(string.Format("ExecuteCompileCheck: Method '{0}' not found.", MethodName), MessageImportance.High);
      }
      else
      {
        if (!method.IsStatic)
        {
          Log.LogError("ExecuteCompileCheck: The method must be declared static.", MessageImportance.High);  
        }
        else
        {
          if (method.GetParameters().Length != 1 || method.GetParameters()[0].ParameterType != typeof(string))
          {
            Log.LogError("ExecuteCompileCheck: The method must have 1 argument of type string declared.", MessageImportance.High);  
          }
          else
          {
            if (method.ReturnType != typeof(IEnumerable<string>))
            {
              Log.LogError("ExecuteCompileCheck: The method must have the return type IEnumerable<string>.", MessageImportance.High);  
            }
            else
            {
              IEnumerable<string> result = (IEnumerable<string>)method.Invoke(null, new object[] { Argument });
              if (result != null)
                foreach (string message in result.Distinct())
                  Log.LogError(message, MessageImportance.High);
            }
          }
        }
      }
    }
  }
}
catch (Exception e)
{
  string prefix = "";
  while (e != null)
  {
    Log.LogError(string.Format("{0}{1} in custom task 'ExecuteCompileCheck'\r\nMessage: {2}\r\n{3}", prefix, e.GetType().Name, e.Message, e.StackTrace));
    e = e.InnerException;
    prefix = "Inner ";
  }
  
}
finally
{
  stopWatch.Stop();
  AppDomain.CurrentDomain.AssemblyResolve -= handler;
  
  Log.LogMessage(MessageImportance.High, string.Format("### Task finished in {0} seconds ###", stopWatch.ElapsedMilliseconds / 1000.0));
}
]]>
      </Code>
    </Task>
  </UsingTask>
</Project>